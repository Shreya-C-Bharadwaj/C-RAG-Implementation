[
  {
    "content": "{\n  // Print callbacks...\n  data->printfile_cb  = lprint_brother_printfile;\n  data->rendjob_cb    = lprint_brother_rendjob;\n  data->rendpage_cb   = lprint_brother_rendpage;\n  data->rstartjob_cb  = lprint_brother_rstartjob;\n  data->rstartpage_cb = lprint_brother_rstartpage;\n  data->rwriteline_cb = lprint_brother_rwriteline;\n  data->status_cb     = lprint_brother_status;\n\n  // Vendor-specific format...\n  data->format = LPRINT_BROTHER_PT_CBP_MIMETYPE;\n\n  if (!strncmp(driver_name, \"brother_ql-\", 11))\n  {\n    // QL-series...\n\n    // Set resolution...\n    // TODO: Add support for 300x600dpi mode for QL-570/580N/700/8xx\n    data->num_resolution  = 1;\n    data->x_resolution[0] = data->y_resolution[0] = 300;\n    data->x_default       = data->y_default = data->x_resolution[0];\n\n    // Basically borderless...\n    data->left_right = 1;\n    data->bottom_top = 1;\n\n    // Supported media...\n    data->num_media = (int)(sizeof(lprint_brother_ql_media) / sizeof(lprint_brother_ql_media[0]));\n    memcpy(data->media, lprint_brother_ql_media, sizeof(lprint_brother_ql_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"roll_dk2205-continuous_2.4x3.9in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"continuous\", sizeof(data->media_ready[0].type));\n\n    data->num_type = 2;\n    data->type[0]  = \"labels\";\n    data->type[1]  = \"continuous\";\n  }\n  else\n  {\n    // PT-series...\n\n    // Set resolution...\n    data->num_resolution  = 1;\n    data->x_resolution[0] = data->y_resolution[0] = 180;\n    data->x_default       = data->y_default = data->x_resolution[0];\n\n    // Basically borderless...\n    data->left_right = 1;\n    data->bottom_top = 1;\n\n    // Supported media...\n    data->num_media = (int)(sizeof(lprint_brother_pt_media) / sizeof(lprint_brother_pt_media[0]));\n    memcpy(data->media, lprint_brother_pt_media, sizeof(lprint_brother_pt_media));\n\n    data->num_source = 1;\n    data->source[0]  = \"main-roll\";\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_wide-2in-tape_1x2in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"continuous\", sizeof(data->media_ready[0].type));\n\n    data->num_type = 2;\n    data->type[0]  = \"continuous\";\n    data->type[1]  = \"continuous-film\";\n    data->type[2]  = \"continuous-removable\";\n  }\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  // 5 darkness/density settings\n  data->darkness_configured = 50;\n  data->darkness_supported  = 5;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-brother.c",
    "start_line": 108,
    "signature": "lprintBrother( pappl_system_t         *system,\t// I - System const char             *driver_name,// I - Driver name const char             *device_uri,\t// I - Device URI const char             *device_id,\t// I - 1284 device ID pappl_pr_driver_data_t *data,\t// I - Pointer to driver data ipp_t                  **attrs,\t// O - Pointer to driver attributes void                   *cbdata)\t// I - Callback data (not used)"
  },
  {
    "content": "{\n  unsigned char\t\tbuffer[32];\t// Status buffer\n  pappl_preason_t\tpreasons;\t// \"printer-state-reasons\" values\n  const char\t\t*media;\t\t// \"media-ready\" value\n\n\n  // Request status...\n  if (!papplDevicePuts(device, \"\\033iS\"))\n    return (false);\n\n  // Read status buffer...\n  if (papplDeviceRead(device, buffer, sizeof(buffer)) < (ssize_t)sizeof(buffer))\n    return (false);\n\n  LPRINT_DEBUG(\"lprint_brother_get_status: Print Head Mark = %02x\\n\", buffer[0]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Size = %02x\\n\", buffer[1]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Reserved = %02x\\n\", buffer[2]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Series Code = %02x\\n\", buffer[3]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Model Code = %02x %02x\\n\", buffer[4], buffer[5]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Reserved = %02x\\n\", buffer[6]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Reserved = %02x\\n\", buffer[7]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Error Info 1 = %02x\\n\", buffer[8]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Error Info 2 = %02x\\n\", buffer[9]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Media Width = %02x\\n\", buffer[10]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Media Type = %02x\\n\", buffer[11]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Reserved = %02x\\n\", buffer[12]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Reserved = %02x\\n\", buffer[13]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Reserved = %02x\\n\", buffer[14]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Mode = %02x\\n\", buffer[15]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Reserved = %02x\\n\", buffer[16]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Media Length = %02x\\n\", buffer[17]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Status Type = %02x\\n\", buffer[18]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Phase Type = %02x\\n\", buffer[19]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Phase Number = %02x %02x\\n\", buffer[20], buffer[21]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Notification # = %02x\\n\", buffer[22]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Reserved = %02x\\n\", buffer[23]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Tape Color = %02x\\n\", buffer[24]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Text Color = %02x\\n\", buffer[25]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Hardware Info = %02x %02x %02x %02x\\n\", buffer[26], buffer[27], buffer[28], buffer[29]);\n  LPRINT_DEBUG(\"lprint_brother_get_status: Reserved = %02x %02x\\n\", buffer[30], buffer[31]);\n\n  // Match ready media...\n  if ((media = lprintMediaMatch(printer, 0, 100 * buffer[10], 100 * buffer[17])) != NULL)\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Detected media is '%s'.\", media);\n\n  // Convert error info to \"printer-state-reasons\" bits...\n  preasons = PAPPL_PREASON_NONE;\n  if (buffer[8] & 0x03)\n    preasons |= PAPPL_PREASON_MEDIA_EMPTY;\n  if (buffer[8] & 0xfc)\n    preasons |= PAPPL_PREASON_OTHER;\n  if (buffer[9] & 0x01)\n    preasons |= PAPPL_PREASON_MEDIA_NEEDED;\n  if (buffer[9] & 0x10)\n    preasons |= PAPPL_PREASON_COVER_OPEN;\n  if (buffer[9] & 0x40)\n    preasons |= PAPPL_PREASON_MEDIA_JAM;\n  if (buffer[9] & 0xae)\n    preasons |= PAPPL_PREASON_OTHER;\n\n  papplPrinterSetReasons(printer, preasons, ~preasons);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-brother.c",
    "start_line": 199,
    "signature": "lprint_brother_get_status( pappl_printer_t *printer,\t\t// I - Printer pappl_device_t  *device)\t\t// I - Device"
  },
  {
    "content": "{\n  int\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n//  lprint_brother_t\tbrother;\t\t\t// Driver data\n\n\n  // Reset the printer...\n  lprint_brother_rstartjob(job, options, device);\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd  = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file '%s': %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  lprint_brother_rstartjob(job, options, device);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-brother.c",
    "start_line": 273,
    "signature": "lprint_brother_printfile( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_brother_t\t\t*brother = (lprint_brother_t *)papplJobGetData(job);\n\t\t\t\t\t// Brother driver data\n\n  (void)options;\n\n  papplDevicePuts(device, \"\\032\");\t// Eject the last page\n\n  free(brother->buffer);\n  free(brother);\n  papplJobSetData(job, NULL);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-brother.c",
    "start_line": 320,
    "signature": "lprint_brother_rendjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_brother_t\t*brother = (lprint_brother_t *)papplJobGetData(job);\n\t\t\t\t\t// Brother driver data\n  unsigned char\tbuffer[13];\t\t// Print Information command buffer\n\n\n  // Write last line\n  lprint_brother_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  // Send print information...\n  buffer[ 0] = 0x1b;\n  buffer[ 1] = 'i';\n  buffer[ 2] = 'z';\n  buffer[ 3] = !strncmp(options->media.type, \"continuous\", 10) ? 0x04 : 0x0c;\n  buffer[ 4] = 0;\n  buffer[ 5] = options->media.size_width / 100;\n  buffer[ 6] = options->media.size_length / 100;\n#if 1\n  buffer[ 7] = options->header.cupsHeight & 255;\n  buffer[ 8] = (options->header.cupsHeight >> 8) & 255;\n  buffer[ 9] = (options->header.cupsHeight >> 16) & 255;\n  buffer[10] = (options->header.cupsHeight >> 24) & 255;\n#else\n  buffer[ 7] = brother->count & 255;\n  buffer[ 8] = (brother->count >> 8) & 255;\n  buffer[ 9] = (brother->count >> 16) & 255;\n  buffer[10] = (brother->count >> 24) & 255;\n#endif // 1\n  buffer[11] = page == 0 ? 0 : 1;\n  buffer[12] = 0;\n\n  if (!papplDeviceWrite(device, buffer, sizeof(buffer)))\n    return (false);\n\n  // Send label data...\n  if (brother->num_bytes > 0 && !papplDeviceWrite(device, brother->buffer, brother->num_bytes))\n    return (false);\n\n  // Eject/cut\n  papplDevicePrintf(device, \"\\033iM%c\", !strncmp(options->media.type, \"continuous\", 10) ? 64 : 0);\n  papplDeviceFlush(device);\n\n  // Free memory and return...\n  lprintDitherFree(&brother->dither);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-brother.c",
    "start_line": 345,
    "signature": "lprint_brother_rendpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_brother_t *brother = (lprint_brother_t *)calloc(1, sizeof(lprint_brother_t));\n\t\t\t\t\t// Brother driver data\n  const char\t*driver_name = papplPrinterGetDriverName(papplJobGetPrinter(job));\n\t\t\t\t\t// Driver name\n  char\t\tbuffer[400];\t\t// Reset buffer\n  int\t\tdarkness;\t\t// Combined darkness\n\n\n  (void)options;\n\n  // Save driver data...\n  papplJobSetData(job, brother);\n\n  // Reset the printer...\n  memset(buffer, 0, sizeof(buffer));\n  if (driver_name && !strncmp(driver_name, \"brother_pt-\", 11))\n  {\n    // Send short reset sequence for PT-series tape printers\n    papplDeviceWrite(device, buffer, 100);\n    brother->is_pt_series = true;\n  }\n  else\n  {\n    // Send long reset sequence for QL-series label printers\n    papplDeviceWrite(device, buffer, sizeof(buffer));\n\n    brother->is_ql_800 = driver_name && !strcmp(driver_name, \"brother_ql-800\");\n  }\n\n  // Get status information...\n  lprint_brother_get_status(papplJobGetPrinter(job), device);\n//  if (!lprint_brother_get_status(papplJobGetPrinter(job), device))\n//    return (false);\n\n  // Reset and set raster mode...\n  if (!papplDevicePuts(device, \"\\033@\\033ia\\001\"))\n    return (false);\n\n  // print-darkness / printer-darkness-configured\n  if ((darkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  return (papplDevicePrintf(device, \"\\033iD%c\", 4 * darkness / 100 + 1));\n}",
    "source": "data/codebase\\lprint-brother.c",
    "start_line": 404,
    "signature": "lprint_brother_rstartjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_brother_t *brother = (lprint_brother_t *)papplJobGetData(job);\n\t\t\t\t\t// Brother driver data\n\n\n  if (page > 0)\n    papplDevicePuts(device, \"\\014\");\t// Eject the previous page\n\n  if (!lprintDitherAlloc(&brother->dither, job, options, CUPS_CSPACE_K, options->header.HWResolution[0] == 300 ? 1.2 : 1.0))\n    return (false);\n\n  brother->count     = 0;\n  brother->num_bytes = 0;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-brother.c",
    "start_line": 462,
    "signature": "lprint_brother_rstartpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_brother_t\t*brother = (lprint_brother_t *)papplJobGetData(job);\n\t\t\t\t\t// Brother driver data\n  unsigned char\t\t*bufptr;\t// Pointer into page buffer\n\n\n  if (!lprintDitherLine(&brother->dither, y, line))\n    return (true);\n\n  if ((brother->alloc_bytes - brother->num_bytes) < (3 + brother->dither.out_width))\n  {\n    size_t temp_alloc = brother->alloc_bytes + brother->dither.out_width + 4096;\n\t\t\t\t      // New allocated size\n    unsigned char *temp = realloc(brother->buffer, temp_alloc);\n\t\t\t\t      // New buffer\n\n    if (!temp)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %lu bytes of memory memory.\", (unsigned long)temp_alloc);\n      return (false);\n    }\n\n    brother->alloc_bytes = temp_alloc;\n    brother->buffer      = temp;\n  }\n\n  bufptr = brother->buffer + brother->num_bytes;\n\n  if (brother->is_ql_800 || brother->dither.output[0] || memcmp(brother->dither.output, brother->dither.output + 1, brother->dither.out_width - 1))\n  {\n    // Non-blank line...\n    // TODO: Add PackBits compression support\n    brother->count += 3 + brother->dither.out_width;\n\n    if (brother->is_pt_series)\n    {\n      *bufptr++ = 'G';\n      *bufptr++ = brother->dither.out_width & 255;\n      *bufptr++ = (brother->dither.out_width >> 8) & 255;\n    }\n    else\n    {\n      *bufptr++ = 'g';\n      *bufptr++ = 0;\n      *bufptr++ = brother->dither.out_width;\n    }\n\n    memcpy(bufptr, brother->dither.output, brother->dither.out_width);\n    brother->num_bytes += 3 + brother->dither.out_width;\n  }\n  else\n  {\n    // Blank line\n    brother->count ++;\n\n    *bufptr = 'Z';\n    brother->num_bytes ++;\n  }\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-brother.c",
    "start_line": 490,
    "signature": "lprint_brother_rwriteline( pappl_job_t         *job,\t\t// I - Job pappl_pr_options_t  *options,\t// I - Job options pappl_device_t      *device,\t// I - Output device unsigned            y,\t\t// I - Line number const unsigned char *line)\t\t// I - Line"
  },
  {
    "content": "{\n  (void)printer;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-brother.c",
    "start_line": 564,
    "signature": "lprint_brother_status( pappl_printer_t *printer)\t\t// I - Printer"
  },
  {
    "content": "{\n  int\t\ti, j;\t\t\t// Looping vars\n  unsigned\tright;\t\t\t// Right margin\n\n\n  // Adjust dithering array and compress to a range of 16 to 239\n  for (i = 0; i < 16; i ++)\n  {\n    for (j = 0; j < 16; j ++)\n    {\n      dither->dither[i][j] = (unsigned char)((LPRINT_BLACK - LPRINT_WHITE) * pow(options->dither[i][j] / 255.0, out_gamma) + LPRINT_WHITE);\n    }\n  }\n\n  // Calculate margins and dimensions...\n  if (!options->header.cupsInteger[CUPS_RASTER_PWG_ImageBoxBottom] || !options->header.cupsInteger[CUPS_RASTER_PWG_ImageBoxLeft] || !options->header.cupsInteger[CUPS_RASTER_PWG_ImageBoxRight] || !options->header.cupsInteger[CUPS_RASTER_PWG_ImageBoxTop])\n  {\n    options->header.cupsInteger[CUPS_RASTER_PWG_ImageBoxLeft]   = options->header.HWResolution[0] * (unsigned)options->media.left_margin / 2540;\n    options->header.cupsInteger[CUPS_RASTER_PWG_ImageBoxTop]    = options->header.HWResolution[1] * (unsigned)options->media.top_margin / 2540;\n    options->header.cupsInteger[CUPS_RASTER_PWG_ImageBoxRight]  = options->header.cupsWidth - options->header.HWResolution[0] * (unsigned)options->media.right_margin / 2540 - 1;\n    options->header.cupsInteger[CUPS_RASTER_PWG_ImageBoxBottom] = options->header.cupsHeight - options->header.HWResolution[1] * (unsigned)options->media.bottom_margin / 2540 - 1;\n  }\n\n  dither->in_left   = options->header.cupsInteger[CUPS_RASTER_PWG_ImageBoxLeft];\n  right             = options->header.cupsInteger[CUPS_RASTER_PWG_ImageBoxRight];\n  dither->in_top    = options->header.cupsInteger[CUPS_RASTER_PWG_ImageBoxTop];\n  dither->in_bottom = options->header.cupsInteger[CUPS_RASTER_PWG_ImageBoxBottom];\n  dither->in_width  = right - dither->in_left + 1;\n  dither->in_height = dither->in_bottom - dither->in_top + 1;\n  dither->out_width = (right - dither->in_left + 8) / 8;\n\n  if (dither->in_width > 65536)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Page too wide.\");\n    return (false);\t\t\t// Protect against large allocations\n  }\n\n  // Calculate input/output color values\n  dither->in_bpp = options->header.cupsBitsPerPixel;\n\n  switch (options->header.cupsColorSpace)\n  {\n    case CUPS_CSPACE_W :\n    case CUPS_CSPACE_SW :\n    case CUPS_CSPACE_RGB :\n    case CUPS_CSPACE_SRGB :\n    case CUPS_CSPACE_ADOBERGB :\n        dither->in_white = 255;\n        break;\n\n    default :\n        dither->in_white = 0;\n        break;\n  }\n\n  switch (out_cspace)\n  {\n    case CUPS_CSPACE_W :\n    case CUPS_CSPACE_SW :\n    case CUPS_CSPACE_RGB :\n    case CUPS_CSPACE_SRGB :\n    case CUPS_CSPACE_ADOBERGB :\n        dither->out_white = 255;\n        break;\n\n    default :\n        dither->out_white = 0;\n        break;\n  }\n\n  // Allocate memory...\n  if ((dither->input[0] = calloc(4 * dither->in_width, sizeof(unsigned char))) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate input buffer.\");\n    return (false);\n  }\n\n  for (i = 1; i < 4; i ++)\n    dither->input[i] = dither->input[0] + i * dither->in_width;\n\n  if ((dither->output = malloc(dither->out_width)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate output buffer.\");\n    return (false);\n  }\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"dither=[\");\n  for (i = 0; i < 16; i ++)\n    papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"  [ %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u ]\", dither->dither[i][0], dither->dither[i][1], dither->dither[i][2], dither->dither[i][3], dither->dither[i][4], dither->dither[i][5], dither->dither[i][6], dither->dither[i][7], dither->dither[i][8], dither->dither[i][9], dither->dither[i][10], dither->dither[i][11], dither->dither[i][12], dither->dither[i][13], dither->dither[i][14], dither->dither[i][15]);\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"]\");\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"in_bottom=%u\", dither->in_bottom);\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"in_left=%u\", dither->in_left);\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"in_top=%u\", dither->in_top);\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"in_width=%u\", dither->in_width);\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"in_bpp=%u\", dither->in_bpp);\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"in_white=%u\", dither->in_white);\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"out_white=%u\", dither->out_white);\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"out_width=%u\", dither->out_width);\n\n  // Return indicating success...\n  return (true);\n}",
    "source": "data/codebase\\lprint-common.c",
    "start_line": 35,
    "signature": "lprintDitherAlloc( lprint_dither_t    *dither,\t\t// I - Dither buffer pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Print options cups_cspace_t      out_cspace,\t// I - Output color space double             out_gamma)\t// I - Output gamma correction"
  },
  {
    "content": "{\n  free(dither->input[0]);\n  free(dither->output);\n\n  memset(dither, 0, sizeof(lprint_dither_t));\n}",
    "source": "data/codebase\\lprint-common.c",
    "start_line": 149,
    "signature": "void lprintDitherFree( lprint_dither_t *dither)\t\t// I - Dither buffer"
  },
  {
    "content": "{\n  unsigned\tx,\t\t\t// Current column\n\t\tcount;\t\t\t// Remaining count\n  unsigned char\t*current,\t\t// Current line\n\t\t*prev,\t\t\t// Previous line\n\t\t*next;\t\t\t// Next line\n  unsigned char\t*dline,\t\t\t// Dither line\n\t\t*outptr,\t\t// Pointer into output\n\t\tbyte,\t\t\t// Current byte\n\t\tbit;\t\t\t// Current bit\n\n\n  // Copy current input line...\n  count = dither->in_width;\n  next  = dither->input[y & 3];\n\n  memset(next, 0, count);\n\n  if (line)\n  {\n    switch (dither->in_bpp)\n    {\n      case 1 : // 1-bit black\n\t  for (line += dither->in_left / 8, byte = *line++, bit = 128 >> (dither->in_left & 7); count > 0; count --, next ++)\n\t  {\n\t    // Convert to 8-bit black...\n\t    if (byte & bit)\n\t      *next = 255;\n\n\t    if (bit > 1)\n\t    {\n\t      bit /= 2;\n\t    }\n\t    else\n\t    {\n\t      bit  = 128;\n\t      byte = *line++;\n\t    }\n\t  }\n\t  break;\n\n      case 8 : // Grayscale or 8-bit black\n\t  if (dither->in_white)\n\t  {\n\t    // Convert grayscale to black...\n\t    for (line += dither->in_left; count > 0; count --, next ++, line ++)\n\t    {\n\t      if (*line < LPRINT_WHITE)\n\t\t*next = 255;\n\t      else if (*line > LPRINT_BLACK)\n\t\t*next = 0;\n\t      else\n\t\t*next = 255 - *line;\n\t    }\n\t  }\n\t  else\n\t  {\n\t    // Copy with clamping...\n\t    for (line += dither->in_left; count > 0; count --, next ++, line ++)\n\t    {\n\t      if (*line < LPRINT_WHITE)\n\t\t*next = 255;\n\t      else if (*line > LPRINT_BLACK)\n\t\t*next = 0;\n\t      else\n\t\t*next = *line;\n\t    }\n\t  }\n\t  break;\n\n      default : // Something else...\n\t  return (false);\n    }\n  }\n\n  // If we are outside the imageable area then don't dither...\n  if (y < (dither->in_top + 1) || y > (dither->in_bottom + 1))\n    return (false);\n\n  // Dither...\n  for (x = 0, count = dither->in_width, prev = dither->input[(y - 2) & 3], current = dither->input[(y - 1) & 3], next = dither->input[y & 3], outptr = dither->output, byte = dither->out_white, bit = 128, dline = dither->dither[y & 15]; count > 0; x ++, count --, prev ++, current ++, next ++)\n  {\n    if (*current)\n    {\n      // Not pure white/blank...\n      if (*current == 255)\n      {\n        // 100% black...\n        byte ^= bit;\n      }\n      else\n      {\n        // Only dither if this pixel does not border 100% white or black...\n\tif ((x > 0 && (current[-1] == 255 || current[-1] == 0)) ||\n\t    (count > 1 && (current[1] == 255 || current[1] == 0)) ||\n\t    *prev == 255 || *prev == 0 || *next == 255 || *next == 0)\n        {\n          // Threshold\n          if (*current > 127)\n\t    byte ^= bit;\n        }\n        else if (*current > dline[x & 15])\n        {\n          // Dither anything else\n\t  byte ^= bit;\n\t}\n      }\n    }\n\n    // Next output bit...\n    if (bit > 1)\n    {\n      bit /= 2;\n    }\n    else\n    {\n      *outptr++ = byte;\n      byte      = dither->out_white;\n      bit       = 128;\n    }\n  }\n\n  // Save last byte of output as needed and return...\n  if (bit < 128)\n    *outptr = byte;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-common.c",
    "start_line": 174,
    "signature": "lprintDitherLine( lprint_dither_t     *dither,\t// I - Dither buffer unsigned            y,\t\t// I - Input line number (starting at `0`) const unsigned char *line)\t\t// I - Input line"
  },
  {
    "content": "{\n  lprint_cmedia_t\t*cmedia;\t// Custom media\n  int\t\t\tfd;\t\t// Custom media file descriptor\n  cups_file_t\t\t*fp;\t\t// Custom media file\n  char\t\t\tfilename[1024],\t// Custom media filename\n\t\t\tline[256];\t// Line from file\n  int\t\t\ti;\t\t// Looping var\n\n\n  // Allocate memory as needed...\n  if ((cmedia = (lprint_cmedia_t *)data->extension) == NULL)\n  {\n    if ((cmedia = (lprint_cmedia_t *)calloc(1, sizeof(lprint_cmedia_t))) == NULL)\n      return (false);\n\n    data->extension = cmedia;\n    data->delete_cb = free_cmedia;\n  }\n\n  // Load any existing custom media sizes...\n  if ((fd = papplPrinterOpenFile(printer, filename, sizeof(filename), /*directory*/NULL, \"custom-media\", \"txt\", \"r\")) < 0)\n    return (true);\n\n  if ((fp = cupsFileOpenFd(fd, \"r\")) == NULL)\n  {\n    close(fd);\n    return (true);\n  }\n\n  for (i = 0; i < data->num_source && cupsFileGets(fp, line, sizeof(line)); i ++)\n    papplCopyString(cmedia->custom_name[i], line, sizeof(cmedia->custom_name[i]));\n\n  cupsFileClose(fp);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-common.c",
    "start_line": 313,
    "signature": "lprintMediaLoad( pappl_printer_t        *printer,\t// I - Printer pappl_pr_driver_data_t *data)\t// I - Driver data"
  },
  {
    "content": "{\n  pappl_pr_driver_data_t pdata;\t\t// Printer driver data\n  lprint_cmedia_t\t*cmedia;\t// Custom media info\n  int\t\t\ti;\t\t// Looping var\n  pwg_media_t\t\t*pwg;\t\t// Current size info\n  const char\t\t*ret = NULL;\t// Return value\n\n\n  papplPrinterGetDriverData(printer, &pdata);\n\n  for (i = 0; i < pdata.num_media; i ++)\n  {\n    if ((!strncmp(pdata.media[i], \"custom_\", 7) || !strncmp(pdata.media[i], \"roll_\", 5)) && (strstr(pdata.media[i], \"_min_\") != NULL || strstr(pdata.media[i], \"_max_\") != NULL))\n      continue;\n\n    if ((pwg = pwgMediaForPWG(pdata.media[i])) == NULL)\n      continue;\n\n    if ((abs(pwg->width - width) <= 100 || !width) && (abs(pwg->length - length) <= 100 || !length))\n    {\n      if (!ret || !strncmp(pdata.media[i], \"custom_\", 7) || !strncmp(pdata.media[i], \"roll_\", 5))\n        ret = pdata.media[i];\n    }\n  }\n\n  if (!ret)\n  {\n    if (!pdata.extension)\n      lprintMediaLoad(printer, &pdata);\n\n    if ((cmedia = (lprint_cmedia_t *)pdata.extension) != NULL)\n    {\n      if (length == 0)\n        pwgFormatSizeName(cmedia->custom_name[source], sizeof(cmedia->custom_name[source]), \"roll\", pdata.source[source], width, length, /*units*/NULL);\n      else\n        pwgFormatSizeName(cmedia->custom_name[source], sizeof(cmedia->custom_name[source]), \"custom\", pdata.source[source], width, length, /*units*/NULL);\n\n      lprintMediaUpdate(printer, &pdata);\n      lprintMediaSave(printer, &pdata);\n\n      ret = cmedia->custom_name[source];\n    }\n  }\n\n  if (ret && strcmp(pdata.media_ready[source].size_name, ret) && (pwg = pwgMediaForPWG(ret)) != NULL)\n  {\n    // Ready media has changed...\n    papplCopyString(pdata.media_ready[source].size_name, ret, sizeof(pdata.media_ready[source].size_name));\n    pdata.media_ready[source].size_width  = pwg->width;\n    pdata.media_ready[source].size_length = pwg->length;\n\n    if (pwg->length == 0)\n      papplCopyString(pdata.media_ready[source].type, \"continuous\", sizeof(pdata.media_ready[source].type));\n    else\n      papplCopyString(pdata.media_ready[source].type, \"label\", sizeof(pdata.media_ready[source].type));\n\n    papplPrinterSetDriverData(printer, &pdata, NULL);\n  }\n\n  return (ret);\n}",
    "source": "data/codebase\\lprint-common.c",
    "start_line": 359,
    "signature": "lprintMediaMatch( pappl_printer_t *printer,\t\t// I - Printer int             source,\t\t// I - \"media-source\" index (0-based) int             width,\t\t// I - Width in hundredths of millimeters or `0` if unknown int             length)\t\t// I - Length in hundredths of millimeters"
  },
  {
    "content": "{\n  lprint_cmedia_t\t*cmedia;\t// Custom media\n  int\t\t\ti,\t\t// Looping var\n\t\t\tfd;\t\t// Custom media file descriptor\n  cups_file_t\t\t*fp;\t\t// Custom media file\n  char\t\t\tfilename[1024];\t// Custom media filename\n\n\n  // Get the custom media...\n  if ((cmedia = (lprint_cmedia_t *)data->extension) == NULL)\n  {\n    // No custom media, delete any existing file...\n    papplPrinterOpenFile(printer, filename, sizeof(filename), /*directory*/NULL, \"custom-media\", \"txt\", \"x\");\n    return (true);\n  }\n\n  // Save custom media sizes...\n  if ((fd = papplPrinterOpenFile(printer, filename, sizeof(filename), /*directory*/NULL, \"custom-media\", \"txt\", \"w\")) < 0)\n    return (true);\n\n  if ((fp = cupsFileOpenFd(fd, \"w\")) == NULL)\n  {\n    close(fd);\n    return (true);\n  }\n\n  for (i = 0; i < data->num_source; i ++)\n    cupsFilePrintf(fp, \"%s\\n\", cmedia->custom_name[i]);\n\n  cupsFileClose(fp);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-common.c",
    "start_line": 432,
    "signature": "lprintMediaSave( pappl_printer_t        *printer,\t// I - Printer pappl_pr_driver_data_t *data)\t// I - Driver data"
  },
  {
    "content": "{\n  int\t\t\ti;\t\t// Looping var\n  pappl_pr_driver_data_t data;\t\t// Driver data\n  lprint_cmedia_t\t*cmedia;\t// Custom label sizes, if any\n  char\t\t\tname[128],\t// Form variable name\n\t\t\ttext[256];\t// Localized text\n  const char\t\t*status = NULL;\t// Status message, if any\n\n\n  LPRINT_DEBUG(\"lprintMediaUI(client=%p, printer=%p(%s))\\n\", client, printer, printer ? papplPrinterGetName(printer) : \"null\");\n\n  // Only allow access as appropriate...\n  if (!papplClientHTMLAuthorize(client))\n    return (true);\n\n  // Get the driver data...\n  papplPrinterGetDriverData(printer, &data);\n\n  LPRINT_DEBUG(\"lprintMediaUI: data.extension=%p\\n\", data.extension);\n  if (!data.extension)\n  {\n    lprintMediaLoad(printer, &data);\n    LPRINT_DEBUG(\"lprintMediaUI: AFTER data.extension=%p\\n\", data.extension);\n  }\n  cmedia = (lprint_cmedia_t *)data.extension;\n\n  if (papplClientGetMethod(client) == HTTP_STATE_POST)\n  {\n    int\t\t\tnum_form = 0;\t// Number of form variable\n    cups_option_t\t*form = NULL;\t// Form variables\n\n    if ((num_form = papplClientGetForm(client, &form)) == 0)\n    {\n      status = papplClientGetLocString(client, \"Invalid form data.\");\n    }\n    else if (!papplClientIsValidForm(client, num_form, form))\n    {\n      status = papplClientGetLocString(client, \"Invalid form submission.\");\n    }\n    else\n    {\n      bool\t\tchanged = false;// Did the custom media list change?\n      pwg_media_t\t*pwg = NULL;\t// PWG media info\n      pappl_media_col_t\t*ready;\t\t// Current ready media\n      const char\t*value,\t\t// Value of form variable\n\t\t\t*custom_width,\t// Custom media width\n\t\t\t*custom_length,\t// Custom media length\n\t\t\t*custom_units;\t// Custom media units\n\n      memset(data.media_ready, 0, sizeof(data.media_ready));\n      for (i = 0, ready = data.media_ready; i < data.num_source; i ++, ready ++)\n      {\n        // size\n        snprintf(name, sizeof(name), \"ready%d-size\", i);\n        if ((value = cupsGetOption(name, num_form, form)) == NULL)\n          continue;\n\n        ready->size_name[0] = '\\0';\n        ready->size_width   = 0;\n        ready->size_length  = 0;\n\n        if (!strcmp(value, \"custom\"))\n        {\n          // Custom size...\n          snprintf(name, sizeof(name), \"ready%d-custom-width\", i);\n          custom_width = cupsGetOption(name, num_form, form);\n          snprintf(name, sizeof(name), \"ready%d-custom-length\", i);\n          custom_length = cupsGetOption(name, num_form, form);\n          snprintf(name, sizeof(name), \"ready%d-custom-units\", i);\n          custom_units = cupsGetOption(name, num_form, form);\n\n          if (custom_width && custom_length && custom_units)\n          {\n            changed = true;\n\n            if (!strcmp(custom_units, \"in\"))\n            {\n\t      ready->size_width  = (int)(2540.0 * strtod(custom_width, NULL));\n\t      ready->size_length = (int)(2540.0 * strtod(custom_length, NULL));\n\t    }\n\t    else\n\t    {\n\t      ready->size_width  = (int)(100.0 * strtod(custom_width, NULL));\n\t      ready->size_length = (int)(100.0 * strtod(custom_length, NULL));\n\t    }\n\n            snprintf(name, sizeof(name), \"ready%d\", i);\n            pwgFormatSizeName(ready->size_name, sizeof(ready->size_name), \"custom\", name, ready->size_width, ready->size_length, custom_units);\n            papplCopyString(cmedia->custom_name[i], ready->size_name, sizeof(cmedia->custom_name[i]));\n\t  }\n        }\n        else if ((pwg = pwgMediaForPWG(value)) != NULL)\n        {\n          // Standard size...\n          papplCopyString(ready->size_name, pwg->pwg, sizeof(ready->size_name));\n          ready->size_width  = pwg->width;\n          ready->size_length = pwg->length;\n        }\n\n        papplLogClient(client, PAPPL_LOGLEVEL_DEBUG, \"ready%d-size='%s',%d,%d\", i, ready->size_name, ready->size_width, ready->size_length);\n\n        // source\n        papplCopyString(ready->source, data.source[i], sizeof(ready->source));\n\n        // xxx-margin\n\tready->bottom_margin = ready->top_margin = data.bottom_top;\n\tready->left_margin = ready->right_margin = data.left_right;\n\n        // tracking\n        snprintf(name, sizeof(name), \"ready%d-tracking\", i);\n        if ((value = cupsGetOption(name, num_form, form)) != NULL)\n        {\n          if (!strcmp(value, \"continuous\"))\n            ready->tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n          else if (!strcmp(value, \"gap\"))\n            ready->tracking = PAPPL_MEDIA_TRACKING_GAP;\n          else if (!strcmp(value, \"mark\"))\n            ready->tracking = PAPPL_MEDIA_TRACKING_MARK;\n          else\n            ready->tracking = PAPPL_MEDIA_TRACKING_WEB;\n        }\n\n        // type\n        snprintf(name, sizeof(name), \"ready%d-type\", i);\n        if ((value = cupsGetOption(name, num_form, form)) != NULL)\n          papplCopyString(ready->type, value, sizeof(ready->type));\n      }\n\n      if (changed)\n      {\n\t// Rebuild media size list and save...\n\tlprintMediaUpdate(printer, &data);\n\tpapplPrinterSetDriverData(printer, &data, NULL);\n\tlprintMediaSave(printer, &data);\n      }\n\n      papplPrinterSetReadyMedia(printer, data.num_source, data.media_ready);\n\n      status = \"Changes saved.\";\n    }\n\n    cupsFreeOptions(num_form, form);\n  }\n\n  papplClientHTMLPrinterHeader(client, printer, \"Media\", 0, NULL, NULL);\n  if (status)\n    papplClientHTMLPrintf(client, \"<div class=\\\"banner\\\">%s</div>\\n\", status);\n\n  papplClientHTMLStartForm(client, papplClientGetURI(client), false);\n\n  papplClientHTMLPuts(client,\n\t\t      \"          <table class=\\\"form\\\">\\n\"\n\t\t      \"            <tbody>\\n\");\n\n  for (i = 0; i < data.num_source; i ++)\n  {\n    snprintf(name, sizeof(name), \"ready%d\", i);\n    media_chooser(client, &data, localize_keyword(client, \"media-source\", data.source[i], text, sizeof(text)), name, data.media_ready + i);\n  }\n\n  papplClientHTMLPrintf(client,\n\t\t\t\"              <tr><th></th><td><input type=\\\"submit\\\" value=\\\"%s\\\"></td></tr>\\n\"\n\t\t\t\"            </tbody>\\n\"\n\t\t\t\"          </table>\"\n\t\t\t\"        </form>\\n\"\n\t\t\t\"        <script>function show_hide_custom(name) {\\n\"\n\t\t        \"  let selelem = document.forms['form'][name + '-size'];\\n\"\n\t\t        \"  let divelem = document.getElementById(name + '-custom');\\n\"\n\t\t        \"  if (selelem.selectedIndex == 0)\\n\"\n\t\t        \"    divelem.style = 'display: inline-block;';\\n\"\n\t\t        \"  else\\n\"\n\t\t        \"    divelem.style = 'display: none;';\\n\"\n\t\t\t\"}</script>\\n\", papplClientGetLocString(client, \"Save Changes\"));\n\n  papplClientHTMLPrinterFooter(client);\n  return (true);\n}",
    "source": "data/codebase\\lprint-common.c",
    "start_line": 475,
    "signature": "lprintMediaUI( pappl_client_t  *client,\t\t// I - Client pappl_printer_t *printer)\t\t// I - Printer"
  },
  {
    "content": "{\n  int\t\t\ti, j;\t\t// Looping vars\n  lprint_cmedia_t\t*cmedia;\t// Custom label sizes\n\n\n  (void)printer;\n\n  // Find the last size in the media list...\n  for (i = 0; i < data->num_media; i ++)\n  {\n    if (!strncmp(data->media[i], \"custom_\", 7) && strncmp(data->media[i], \"custom_min_\", 11) && strncmp(data->media[i], \"custom_max_\", 11))\n      break;\n  }\n\n  // Then copy any custom sizes over...\n  if ((cmedia = (lprint_cmedia_t *)data->extension) != NULL)\n  {\n    for (j = 0; j < data->num_source && i < PAPPL_MAX_MEDIA; j ++)\n    {\n      if (cmedia->custom_name[j][0])\n        data->media[i ++] = cmedia->custom_name[j];\n    }\n  }\n\n  data->num_media = i;\n\n  LPRINT_DEBUG(\"lprintMediaUpdate: num_media=%d\\n\", data->num_media);\n  for (i = 0; i < data->num_media; i ++)\n    LPRINT_DEBUG(\"lprintMediaUpdate: media[%d]='%s'\\n\", i, data->media[i]);\n}",
    "source": "data/codebase\\lprint-common.c",
    "start_line": 661,
    "signature": "void lprintMediaUpdate( pappl_printer_t        *printer,\t// I - Printer pappl_pr_driver_data_t *data)\t// I - Driver data"
  },
  {
    "content": "{\n  const unsigned char\t*srcptr,\t// Current byte pointer\n\t\t\t*srcend,\t// End-of-line byte pointer\n\t\t\t*srclptr,\t// Start of literal sequence\n\t\t\t*srcrptr;\t// Start of repeated sequence\n  unsigned char\t\t*dstptr;\t// Pointer into compression buffer\n  unsigned\t\tcount,\t\t// Current count\n\t\t\tsrclcount,\t// Count of literal bytes for output\n\t\t\tsrcrcount;\t// Count of repeated bytes for output\n\n\n  // Do TIFF PackBits compression over the source buffer...\n  srcptr = srclptr = src;\n  srcend = src + srclen - 1;\n  dstptr = dst;\n\n  while (srclptr <= srcend)\n  {\n    // Scan for literal and repeated sequences...\n    srclcount = srcptr - srclptr;\n    srcrcount = 0;\n\n    while (srcptr <= srcend)\n    {\n      // Extend literal sequence, if any...\n      while (srcptr < srcend && srcptr[0] != srcptr[1])\n\tsrcptr ++;\n\n      srclcount = srcptr - srclptr;\n      srcrcount = 0;\n\n      if (srcptr == srcend)\n      {\n        // Last byte, stop here...\n\tsrcptr ++;\n\tsrclcount ++;\n\tbreak;\n      }\n\n      // Count a run...\n      srcrptr = srcptr;\n\n      while (srcptr < srcend && srcptr[0] == srcptr[1])\n      {\n\tsrcptr ++;\n\tsrcrcount ++;\n      }\n\n      srcptr ++;\n      srcrcount ++;\n\n      // Only stop to encode if the repeated sequence is long enough to make sense...\n      if (srcrcount > 2 || srcrptr == srclptr)\n        break;\n    }\n\n    // Encode literal byte sequences...\n    while (srclcount > 0)\n    {\n      if (srclcount > 128)\n\tcount = 128;\n      else\n\tcount = srclcount;\n\n      *dstptr++ = (unsigned char)(count - 1);\n      memcpy(dstptr, srclptr, count);\n      dstptr += count;\n      srclptr += count;\n      srclcount -= count;\n    }\n\n    // Encode repeated byte sequences...\n    while (srcrcount > 1)\n    {\n      if (srcrcount > 128)\n\tcount = 128;\n      else\n\tcount = srcrcount;\n\n      *dstptr++ = (unsigned char)(257 - count);\n      *dstptr++ = *srcrptr;\n      srcrcount -= count;\n    }\n\n    // Reset the literal pointer and continue...\n    srclptr = srcptr - srcrcount;\n  }\n\n  return ((size_t)(dstptr - dst));\n}",
    "source": "data/codebase\\lprint-common.c",
    "start_line": 719,
    "signature": "lprintPackBitsCompress( unsigned char       *dst,\t\t// I - Destination buffer const unsigned char *src,\t\t// I - Source buffer size_t              srclen)\t\t// I - Number of source bytes (at least 3)"
  },
  {
    "content": "{\n  free(data->extension);\n}",
    "source": "data/codebase\\lprint-common.c",
    "start_line": 819,
    "signature": "static void free_cmedia( pappl_printer_t        *printer,\t// I - Printer (unused) pappl_pr_driver_data_t *data)\t// I - Driver data"
  },
  {
    "content": "{\n  const char\t*loctext;\t\t// Localized text\n  char\t\tkey[256];\t\t// Localization key\n\n\n  snprintf(key, sizeof(key), \"%s.%s\", attrname, keyword);\n  if ((loctext = papplClientGetLocString(client, key)) != key)\n  {\n    // Use localized string...\n    papplCopyString(buffer, loctext, bufsize);\n  }\n  else if (!strcmp(attrname, \"media\"))\n  {\n    // Create a dimensional name for the size...\n    pwg_media_t *pwg = pwgMediaForPWG(keyword);\n\t\t\t\t\t// PWG media size info\n\n    LPRINT_DEBUG(\"localize_keyword: keyword='%s', pwg=%p(%dx%d)\\n\", keyword, pwg, pwg ? pwg->width : 0, pwg ? pwg->length : 0);\n    if (pwg)\n    {\n      if ((pwg->width % 100) == 0 && (pwg->width % 2540) != 0)\n\tsnprintf(buffer, bufsize, \"%d x %dmm Custom Label\", pwg->width / 100, pwg->length / 100);\n      else\n\tsnprintf(buffer, bufsize, \"%g x %g\u02ba Custom Label\", pwg->width / 2540.0, pwg->length / 2540.0);\n    }\n    else\n    {\n      snprintf(buffer, bufsize, \"Invalid '%s'\", keyword);\n    }\n  }\n  else\n  {\n    // Convert \"separated-words\" to \"Separated Words\"...\n    char\t*ptr;\t\t\t// Pointer into string\n\n    papplCopyString(buffer, keyword, bufsize);\n    *buffer = (char)toupper(*buffer & 255);\n\n    for (ptr = buffer + 1; *ptr; ptr ++)\n    {\n      if (*ptr == '-' && ptr[1])\n      {\n\t*ptr++ = ' ';\n\t*ptr   = (char)toupper(*ptr & 255);\n      }\n    }\n  }\n\n  return (buffer);\n}",
    "source": "data/codebase\\lprint-common.c",
    "start_line": 833,
    "signature": "localize_keyword( pappl_client_t *client,\t\t// I - Client const char     *attrname,\t\t// I - Attribute name const char     *keyword,\t\t// I - Keyword value char           *buffer,\t\t// I - String buffer size_t         bufsize)\t\t// I - Size of string buffer"
  },
  {
    "content": "{\n  int\t\ti,\t\t\t// Looping vars\n\t\tcur_index = 0,\t\t// Current size index\n\t        sel_index = 0;\t\t// Selected size index...\n  pwg_media_t\t*pwg;\t\t\t// PWG media size info\n  char\t\ttext[256];\t\t// Localized text\n  const char\t*min_size = NULL,\t// Minimum size\n\t\t*max_size = NULL;\t// Maximum size\n\n\n  // media-size\n  papplLocFormatString(papplClientGetLoc(client), text, sizeof(text), \"%s Media\", title);\n  papplClientHTMLPrintf(client, \"              <tr><th>%s:</th><td>\", text);\n  for (i = 0; i < driver_data->num_media && (!min_size || !max_size); i ++)\n  {\n    if (!strncmp(driver_data->media[i], \"custom_\", 7) || !strncmp(driver_data->media[i], \"roll_\", 5))\n    {\n      if (strstr(driver_data->media[i], \"_min_\"))\n        min_size = driver_data->media[i];\n      else if (strstr(driver_data->media[i], \"_max_\"))\n        max_size = driver_data->media[i];\n    }\n  }\n  if (min_size && max_size)\n  {\n    papplClientHTMLPrintf(client, \"<select name=\\\"%s-size\\\" onChange=\\\"show_hide_custom('%s');\\\"><option value=\\\"custom\\\">%s</option>\", name, name, papplClientGetLocString(client, \"New Custom Size\"));\n    cur_index ++;\n  }\n  else\n    papplClientHTMLPrintf(client, \"<select name=\\\"%s-size\\\">\", name);\n\n  for (i = 0; i < driver_data->num_media; i ++)\n  {\n    if (!strncmp(driver_data->media[i], \"custom_\", 7) || !strncmp(driver_data->media[i], \"roll_\", 5))\n    {\n      if (strstr(driver_data->media[i], \"_min_\"))\n      {\n        min_size = driver_data->media[i];\n        continue;\n      }\n      else if (strstr(driver_data->media[i], \"_max_\"))\n      {\n        max_size = driver_data->media[i];\n        continue;\n      }\n    }\n\n    if (!strcmp(driver_data->media[i], media->size_name))\n      sel_index = cur_index;\n\n    papplClientHTMLPrintf(client, \"<option value=\\\"%s\\\"%s>%s</option>\", driver_data->media[i], sel_index == cur_index ? \" selected\" : \"\", localize_keyword(client, \"media\", driver_data->media[i], text, sizeof(text)));\n    cur_index ++;\n  }\n\n  if (min_size && max_size)\n  {\n    int cur_width, min_width, max_width;// Current/min/max width\n    int cur_length, min_length, max_length;\n\t\t\t\t\t// Current/min/max length\n    const char *cur_units;\t\t// Current units\n\n    if ((pwg = pwgMediaForPWG(min_size)) != NULL)\n    {\n      min_width  = pwg->width;\n      min_length = pwg->length;\n    }\n    else\n    {\n      min_width  = 1 * 2540;\n      min_length = 1 * 2540;\n    }\n\n    if ((pwg = pwgMediaForPWG(max_size)) != NULL)\n    {\n      max_width  = pwg->width;\n      max_length = pwg->length;\n    }\n    else\n    {\n      max_width  = 9 * 2540;\n      max_length = 22 * 2540;\n    }\n\n    if ((cur_width = media->size_width) < min_width)\n      cur_width = min_width;\n    else if (cur_width > max_width)\n      cur_width = max_width;\n\n    if ((cur_length = media->size_length) < min_length)\n      cur_length = min_length;\n    else if (cur_length > max_length)\n      cur_length = max_length;\n\n    if ((cur_units = media->size_name + strlen(media->size_name) - 2) < media->size_name)\n      cur_units = \"in\";\n\n    if (!strcmp(cur_units, \"mm\"))\n      papplClientHTMLPrintf(client, \"</select><div style=\\\"display: %s;\\\" id=\\\"%s-custom\\\"><input type=\\\"number\\\" name=\\\"%s-custom-width\\\" min=\\\"%.2f\\\" max=\\\"%.2f\\\" value=\\\"%.2f\\\" step=\\\".01\\\" placeholder=\\\"%s\\\">x<input type=\\\"number\\\" name=\\\"%s-custom-length\\\" min=\\\"%.2f\\\" max=\\\"%.2f\\\" value=\\\"%.2f\\\" step=\\\".01\\\" placeholder=\\\"%s\\\"><div class=\\\"switch\\\"><input type=\\\"radio\\\" id=\\\"%s-custom-units-in\\\" name=\\\"%s-custom-units\\\" value=\\\"in\\\"><label for=\\\"%s-custom-units-in\\\">in</label><input type=\\\"radio\\\" id=\\\"%s-custom-units-mm\\\" name=\\\"%s-custom-units\\\" value=\\\"mm\\\" checked><label for=\\\"%s-custom-units-mm\\\">mm</label></div></div>\\n\", sel_index == 0 ? \"inline-block\" : \"none\", name, name, min_width / 2540.0, max_width / 100.0, cur_width / 100.0, papplClientGetLocString(client, \"Width\"), name, min_length / 2540.0, max_length / 100.0, cur_length / 100.0, papplClientGetLocString(client, \"Height\"), name, name, name, name, name, name);\n    else\n      papplClientHTMLPrintf(client, \"</select><div style=\\\"display: %s;\\\" id=\\\"%s-custom\\\"><input type=\\\"number\\\" name=\\\"%s-custom-width\\\" min=\\\"%.2f\\\" max=\\\"%.2f\\\" value=\\\"%.2f\\\" step=\\\".01\\\" placeholder=\\\"%s\\\">x<input type=\\\"number\\\" name=\\\"%s-custom-length\\\" min=\\\"%.2f\\\" max=\\\"%.2f\\\" value=\\\"%.2f\\\" step=\\\".01\\\" placeholder=\\\"%s\\\"><div class=\\\"switch\\\"><input type=\\\"radio\\\" id=\\\"%s-custom-units-in\\\" name=\\\"%s-custom-units\\\" value=\\\"in\\\" checked><label for=\\\"%s-custom-units-in\\\">in</label><input type=\\\"radio\\\" id=\\\"%s-custom-units-mm\\\" name=\\\"%s-custom-units\\\" value=\\\"mm\\\"><label for=\\\"%s-custom-units-mm\\\">mm</label></div></div>\\n\", sel_index == 0 ? \"inline-block\" : \"none\", name, name, min_width / 2540.0, max_width / 100.0, cur_width / 2540.0, papplClientGetLocString(client, \"Width\"), name, min_length / 2540.0, max_length / 100.0, cur_length / 2540.0, papplClientGetLocString(client, \"Height\"), name, name, name, name, name, name);\n  }\n  else\n  {\n    papplClientHTMLPuts(client, \"</select>\\n\");\n  }\n\n  // media-tracking (if needed)\n  if (driver_data->tracking_supported)\n  {\n    pappl_media_tracking_t tracking;\t// Tracking value\n    static const char * const trackings[] =\n    {\t\t\t\t\t// Tracking strings\n      \"continuous\",\n      \"gap\",\n      \"mark\",\n      \"web\"\n    };\n\n    papplClientHTMLPrintf(client, \"                <select name=\\\"%s-tracking\\\">\", name);\n    for (i = 0, tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS; tracking <= PAPPL_MEDIA_TRACKING_WEB; i ++, tracking *= 2)\n    {\n      if (!(driver_data->tracking_supported & tracking))\n\tcontinue;\n\n      papplClientHTMLPrintf(client, \"<option value=\\\"%s\\\"%s>%s</option>\", trackings[i], tracking == media->tracking ? \" selected\" : \"\", localize_keyword(client, \"media-tracking\", trackings[i], text, sizeof(text)));\n    }\n    papplClientHTMLPuts(client, \"</select>\\n\");\n  }\n\n  // media-type\n  papplClientHTMLPrintf(client, \"                <select name=\\\"%s-type\\\">\", name);\n  for (i = 0; i < driver_data->num_type; i ++)\n  {\n    papplClientHTMLPrintf(client, \"<option value=\\\"%s\\\"%s>%s</option>\", driver_data->type[i], !strcmp(driver_data->type[i], media->type) ? \" selected\" : \"\", localize_keyword(client, \"media-type\", driver_data->type[i], text, sizeof(text)));\n  }\n  papplClientHTMLPrintf(client, \"</select></td></tr>\\n\");\n}",
    "source": "data/codebase\\lprint-common.c",
    "start_line": 895,
    "signature": "static void media_chooser( pappl_client_t         *client,\t// I - Client pappl_pr_driver_data_t *driver_data,// I - Driver data const char             *title,\t// I - Title for field const char             *name,\t// I - Form name/prefix pappl_media_col_t      *media)\t// I - Current media values"
  },
  {
    "content": "{\n  data->printfile_cb  = lprint_cpcl_printfile;\n  data->rendjob_cb    = lprint_cpcl_rendjob;\n  data->rendpage_cb   = lprint_cpcl_rendpage;\n  data->rstartjob_cb  = lprint_cpcl_rstartjob;\n  data->rstartpage_cb = lprint_cpcl_rstartpage;\n  data->rwriteline_cb = lprint_cpcl_rwriteline;\n  data->status_cb     = lprint_cpcl_status;\n  data->format        = LPRINT_CPCL_MIMETYPE;\n\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if (!strncmp(driver_name, \"cpcl_hma300e-\", 13))\n  {\n    data->num_media = (int)(sizeof(lprint_hma300e_media) / sizeof(lprint_hma300e_media[0]));\n    memcpy(data->media, lprint_hma300e_media, sizeof(lprint_hma300e_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"roll_main_80x150mm\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"continuous\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    data->num_media = (int)(sizeof(lprint_cpcl_media) / sizeof(lprint_cpcl_media[0]));\n    memcpy(data->media, lprint_cpcl_media, sizeof(lprint_cpcl_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  data->bottom_top = data->left_right = 1;\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  data->tracking_supported = PAPPL_MEDIA_TRACKING_MARK | PAPPL_MEDIA_TRACKING_WEB | PAPPL_MEDIA_TRACKING_CONTINUOUS;\n\n  data->num_type = 3;\n  data->type[0]  = \"continuous\";\n  data->type[1]  = \"labels\";\n  data->type[2]  = \"labels-continuous\";\n\n  data->tear_offset_configured   = 0;\n  data->tear_offset_supported[0] = -1500;\n  data->tear_offset_supported[1] = 1500;\n\n  data->speed_default      = 0;\n  data->speed_supported[0] = 2540;\n  data->speed_supported[1] = 4 * 2540;\n\n  data->darkness_configured = 50;\n  data->darkness_supported  = 30;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-cpcl.c",
    "start_line": 114,
    "signature": "lprintCPCL( pappl_system_t         *system,\t// I - System const char             *driver_name,// I - Driver name const char             *device_uri,\t// I - Device URI const char             *device_id,\t// I - 1284 device ID pappl_pr_driver_data_t *data,\t// I - Pointer to driver data ipp_t                  **attrs,\t// O - Pointer to driver attributes void                   *cbdata)\t// I - Callback data (not used)"
  },
  {
    "content": "{\n\n  int\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd  = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file '%s': %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  // Copy print data...\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-cpcl.c",
    "start_line": 198,
    "signature": "lprint_cpcl_printfile( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_cpcl_t\t\t*cpcl = (lprint_cpcl_t *)papplJobGetData(job);\n\t\t\t\t\t// CPCL driver data\n\n  (void)options;\n  (void)device;\n\n  free(cpcl);\n  papplJobSetData(job, NULL);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-cpcl.c",
    "start_line": 241,
    "signature": "lprint_cpcl_rendjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_cpcl_t\t*cpcl = (lprint_cpcl_t *)papplJobGetData(job);\n\t\t\t\t\t// CPCL driver data\n  int\tdarkness;\t\t\t// Composite darkness value\n\n\n  (void)page;\n\n  // Write last line\n  lprint_cpcl_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  // Set options\n  papplDevicePrintf(device, \"PRESENT-AT %d 4\\r\\n\", options->media.top_offset * options->printer_resolution[1] / 2540);\n\n  if ((darkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"TONE %d\\r\\n\", 2 * darkness);\n\n  if (options->print_speed > 0)\n    papplDevicePrintf(device, \"SPEED %d\\r\\n\", 5 * options->print_speed / (4 * 2540));\n\n  if (options->finishings & PAPPL_FINISHINGS_TRIM)\n    papplDevicePuts(device, \"CUT\\r\\n\");\n\n  if (options->media.type[0] && strcmp(options->media.type, \"labels\"))\n  {\n    // Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if (options->media.tracking != PAPPL_MEDIA_TRACKING_CONTINUOUS)\n    papplDevicePuts(device, \"FORM\\r\\n\");\n\n  // Eject\n  papplDevicePuts(device, \"PRINT\\r\\n\");\n  papplDeviceFlush(device);\n\n  // Free memory and return...\n  lprintDitherFree(&cpcl->dither);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-cpcl.c",
    "start_line": 264,
    "signature": "lprint_cpcl_rendpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_cpcl_t\t\t*cpcl = (lprint_cpcl_t *)calloc(1, sizeof(lprint_cpcl_t));\n\t\t\t\t\t// CPCL driver data\n\n\n  (void)options;\n  (void)device;\n\n  // Save driver data...\n  papplJobSetData(job, cpcl);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-cpcl.c",
    "start_line": 321,
    "signature": "lprint_cpcl_rstartjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_cpcl_t\t*cpcl = (lprint_cpcl_t *)papplJobGetData(job);\n\t\t\t\t\t// CPCL driver data\n\n\n  (void)page;\n\n  // Initialize the dither buffer...\n  if (!lprintDitherAlloc(&cpcl->dither, job, options, CUPS_CSPACE_W, options->header.HWResolution[0] == 300 ? 1.2 : 1.0))\n    return (false);\n\n  // Initialize the printer...\n  papplDevicePrintf(device, \"! 0 %u %u %u %u\\r\\n\", options->header.HWResolution[0], options->header.HWResolution[1], options->header.cupsHeight, options->header.NumCopies ? options->header.NumCopies : 1);\n  papplDevicePrintf(device, \"PAGE-WIDTH %u\\r\\n\", options->header.cupsWidth);\n  papplDevicePrintf(device, \"PAGE-HEIGHT %u\\r\\n\", options->header.cupsHeight);\n\n\n  // Start the page image...\n  papplDevicePuts(device, \"CLS\\n\");\n  papplDevicePrintf(device, \"BITMAP 0,0,%u,%u,1,\", cpcl->dither.out_width, options->header.cupsHeight);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-cpcl.c",
    "start_line": 345,
    "signature": "lprint_cpcl_rstartpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_cpcl_t\t\t*cpcl = (lprint_cpcl_t *)papplJobGetData(job);\n\t\t\t\t\t// CPCL driver data\n\n\n  (void)options;\n\n  // Dither and write the line...\n  if (lprintDitherLine(&cpcl->dither, y, line))\n  {\n    if (cpcl->dither.output[0] || memcmp(cpcl->dither.output, cpcl->dither.output + 1, cpcl->dither.out_width - 1))\n    {\n      papplDevicePrintf(device, \"CG %u 1 0 %d \", (unsigned)cpcl->dither.out_width, y);\n      papplDeviceWrite(device, cpcl->dither.output, cpcl->dither.out_width);\n      papplDevicePuts(device, \"\\r\\n\");\n      papplDeviceFlush(device);\n    }\n  }\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-cpcl.c",
    "start_line": 380,
    "signature": "lprint_cpcl_rwriteline( pappl_job_t         *job,\t\t// I - Job pappl_pr_options_t  *options,\t// I - Job options pappl_device_t      *device,\t// I - Output device unsigned            y,\t\t// I - Line number const unsigned char *line)\t\t// I - Line"
  },
  {
    "content": "{\n  (void)printer;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-cpcl.c",
    "start_line": 414,
    "signature": "lprint_cpcl_status( pappl_printer_t *printer)\t\t// I - Printer"
  },
  {
    "content": "{\n  LPRINT_DLANG_LABEL,\t\t\t// Label printing\n  LPRINT_DLANG_TAPE\t\t\t// Tape printing\n} lprint_dlang_t;",
    "source": "data/codebase\\lprint-dymo.c",
    "start_line": 18,
    "signature": "typedef enum lprint_dlang_e"
  },
  {
    "content": "{\n  data->printfile_cb  = lprint_dymo_printfile;\n  data->rendjob_cb    = lprint_dymo_rendjob;\n  data->rendpage_cb   = lprint_dymo_rendpage;\n  data->rstartjob_cb  = lprint_dymo_rstartjob;\n  data->rstartpage_cb = lprint_dymo_rstartpage;\n  data->rwriteline_cb = lprint_dymo_rwriteline;\n  data->status_cb     = lprint_dymo_status;\n\n  if (!strncmp(driver_name, \"dymo_lm-\", 8) || strstr(driver_name, \"-tape\"))\n  {\n    // Vendor-specific format...\n    data->format = \"application/vnd.dymo-lm\";\n\n    // Set pages-per-minute based on 3\" of tape; not exact but\n    // we need to report something...\n    data->ppm = 20;\n\n    // Tape printers operate at 180dpi\n    data->num_resolution  = 1;\n    data->x_resolution[0] = 180;\n    data->y_resolution[0] = 180;\n\n    data->x_default = data->y_default = 180;\n\n    data->left_right = 1;\n    data->bottom_top = 1;\n\n    data->num_media = (int)(sizeof(lprint_dymo_tape) / sizeof(lprint_dymo_tape[0]));\n    memcpy(data->media, lprint_dymo_tape, sizeof(lprint_dymo_tape));\n\n    data->num_source = 1;\n    data->source[0]  = \"main-roll\";\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_wide-2in-tape_1x2in\", sizeof(data->media_ready[0].size_name));\n  }\n  else\n  {\n    // Vendor-specific format...\n    data->format = \"application/vnd.dymo-lw\";\n\n    // Set pages-per-minute based on 1.125x3.5\" address labels; not exact but\n    // we need to report something...\n    if (strstr(driver_name, \"-turbo\"))\n      data->ppm = 60;\n    else\n      data->ppm = 30;\n\n    // Label printers operate at 300dpi\n    data->num_resolution  = 1;\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n\n    data->x_default = data->y_default = 300;\n\n    // Media...\n    data->left_right = 100;\n    data->bottom_top = 525;\n\n    data->num_media = (int)(sizeof(lprint_dymo_label) / sizeof(lprint_dymo_label[0]));\n    memcpy(data->media, lprint_dymo_label, sizeof(lprint_dymo_label));\n\n    if (strstr(driver_name, \"-twin\"))\n    {\n      data->num_source = 2;\n      data->source[0]  = \"main-roll\";\n      data->source[1]  = \"alternate-roll\";\n\n      papplCopyString(data->media_ready[0].size_name, \"oe_address-label_1.125x3.5in\", sizeof(data->media_ready[0].size_name));\n      papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n      papplCopyString(data->media_ready[1].size_name, \"oe_address-label_1.125x3.5in\", sizeof(data->media_ready[1].size_name));\n      papplCopyString(data->media_ready[1].type, \"labels\", sizeof(data->media_ready[0].type));\n    }\n    else\n    {\n      data->num_source = 1;\n      data->source[0]  = \"main-roll\";\n\n      papplCopyString(data->media_ready[0].size_name, \"oe_address-label_1.125x3.5in\", sizeof(data->media_ready[0].size_name));\n      papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n    }\n  }\n\n  data->tracking_supported = PAPPL_MEDIA_TRACKING_WEB;\n\n  data->num_type = 1;\n  data->type[0]  = \"labels\";\n\n  // Darkness/density support...\n  data->darkness_configured = 50;\n  data->darkness_supported  = 4;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-dymo.c",
    "start_line": 120,
    "signature": "lprintDYMO( pappl_system_t         *system,\t// I - System const char             *driver_name,// I - Driver name const char             *device_uri,\t// I - Device URI const char             *device_id,\t// I - 1284 device ID pappl_pr_driver_data_t *data,\t// I - Pointer to driver data ipp_t                  **attrs,\t// O - Pointer to driver attributes void                   *cbdata)\t// I - Callback data (not used)"
  },
  {
    "content": "{\n  const char\t*driver_name;\t\t// Driver name\n\n\n  driver_name = papplPrinterGetDriverName(papplJobGetPrinter(job));\n\n  if (!strncmp(driver_name, \"dymo_lm-\", 8) || strstr(driver_name, \"-tape\"))\n  {\n    dymo->dlang = LPRINT_DLANG_TAPE;\n\n    if (!strcmp(driver_name, \"dymo_lw-duo-tape\") || !strcmp(driver_name, \"dymo_lw-duo-tape-128\") || !strcmp(driver_name, \"dymo_lw-450-duo-tape\"))\n    {\n      dymo->min_leader    = 61;\n      dymo->normal_leader = 14;\n    }\n    else if (!strcmp(driver_name, \"dymo_lm-pnp\"))\n    {\n      dymo->min_leader    = 58;\n      dymo->normal_leader = 17;\n    }\n    else\n    {\n      dymo->min_leader    = 55;\n      dymo->normal_leader = 20;\n    }\n  }\n  else\n  {\n    dymo->dlang = LPRINT_DLANG_LABEL;\n  }\n}",
    "source": "data/codebase\\lprint-dymo.c",
    "start_line": 228,
    "signature": "static void lprint_dymo_init( pappl_job_t   *job,\t\t\t// I - Job lprint_dymo_t *dymo)\t\t// O - Driver data"
  },
  {
    "content": "{\n  int\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n  lprint_dymo_t\tdymo;\t\t\t// Driver data\n\n\n  // Initialize driver data...\n  lprint_dymo_init(job, &dymo);\n\n  // Reset the printer...\n  lprint_dymo_rstartjob(job, options, device);\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd  = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file '%s': %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  lprint_dymo_rstartjob(job, options, device);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-dymo.c",
    "start_line": 270,
    "signature": "lprint_dymo_printfile( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_dymo_t\t\t*dymo = (lprint_dymo_t *)papplJobGetData(job);\n\t\t\t\t\t// DYMO driver data\n\n  (void)options;\n\n  free(dymo);\n  papplJobSetData(job, NULL);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-dymo.c",
    "start_line": 320,
    "signature": "lprint_dymo_rendjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_dymo_t\t*dymo = (lprint_dymo_t *)papplJobGetData(job);\n\t\t\t\t\t// DYMO driver data\n  char\t\tbuffer[256];\t\t// Command buffer\n\n\n  (void)page;\n\n  lprint_dymo_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  switch (dymo->dlang)\n  {\n    case LPRINT_DLANG_LABEL :\n        break;\n\n    case LPRINT_DLANG_TAPE :\n\t// Skip and cut...\n        papplDevicePrintf(device, \"\\033D%c\", 0);\n        memset(buffer, 0x16, dymo->min_leader);\n        papplDeviceWrite(device, buffer, dymo->min_leader);\n        break;\n  }\n\n  // Eject/cut\n  papplDevicePuts(device, \"\\033E\");\n  papplDeviceFlush(device);\n\n  // Free memory and return...\n  lprintDitherFree(&dymo->dither);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-dymo.c",
    "start_line": 342,
    "signature": "lprint_dymo_rendpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_dymo_t\t\t*dymo = (lprint_dymo_t *)calloc(1, sizeof(lprint_dymo_t));\n\t\t\t\t\t// DYMO driver data\n  char\t\t\tbuffer[23];\t// Buffer for reset command\n\n\n  (void)options;\n\n  // Initialize driver data...\n  lprint_dymo_init(job, dymo);\n\n  papplJobSetData(job, dymo);\n\n  // Reset the printer...\n  switch (dymo->dlang)\n  {\n    case LPRINT_DLANG_LABEL :\n\tpapplDevicePuts(device, \"\\033\\033\\033\\033\\033\\033\\033\\033\\033\\033\"\n\t\t\t\t\"\\033\\033\\033\\033\\033\\033\\033\\033\\033\\033\"\n\t\t\t\t\"\\033\\033\\033\\033\\033\\033\\033\\033\\033\\033\"\n\t\t\t\t\"\\033\\033\\033\\033\\033\\033\\033\\033\\033\\033\"\n\t\t\t\t\"\\033\\033\\033\\033\\033\\033\\033\\033\\033\\033\"\n\t\t\t\t\"\\033\\033\\033\\033\\033\\033\\033\\033\\033\\033\"\n\t\t\t\t\"\\033\\033\\033\\033\\033\\033\\033\\033\\033\\033\"\n\t\t\t\t\"\\033\\033\\033\\033\\033\\033\\033\\033\\033\\033\"\n\t\t\t\t\"\\033\\033\\033\\033\\033\\033\\033\\033\\033\\033\"\n\t\t\t\t\"\\033\\033\\033\\033\\033\\033\\033\\033\\033\\033\"\n\t\t\t\t\"\\033@\");\n        break;\n\n    case LPRINT_DLANG_TAPE :\n        // Send nul bytes to clear input buffer...\n        memset(buffer, 0, sizeof(buffer));\n        papplDeviceWrite(device, buffer, sizeof(buffer));\n\n        // Set tape color to black on white...\n        papplDevicePrintf(device, \"\\033C%c\", 0);\n        break;\n  }\n\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-dymo.c",
    "start_line": 386,
    "signature": "lprint_dymo_rstartjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  pappl_pr_driver_data_t data;\t\t// Generic driver data\n  lprint_dymo_t\t*dymo = (lprint_dymo_t *)papplJobGetData(job);\n\t\t\t\t\t// DYMO driver data\n  int\t\tdarkness = options->darkness_configured + options->print_darkness;\n\t\t\t\t\t// Combined density\n  const char\t*density = \"cdeg\";\t// Density codes\n  int\t\ti;\t\t\t// Looping var\n  char\t\tbuffer[256];\t\t// Command buffer\n  double\tout_gamma = 1.0;\t// Output gamma correction\n\n\n\n  (void)page;\n\n  if (options->header.cupsWidth > 2048)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Raster data too large for printer.\");\n    return (false);\n  }\n\n  if (options->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n\n  if (!lprintDitherAlloc(&dymo->dither, job, options, CUPS_CSPACE_K, out_gamma))\n    return (false);\n\n  dymo->feed = 0;\n\n  switch (dymo->dlang)\n  {\n    case LPRINT_DLANG_LABEL :\n\tpapplDevicePrintf(device, \"\\033Q%c%c\", 0, 0);\n\tpapplDevicePrintf(device, \"\\033B%c\", 0);\n\tpapplDevicePrintf(device, \"\\033L%c%c\", options->header.cupsHeight >> 8, options->header.cupsHeight);\n\tpapplDevicePrintf(device, \"\\033D%c\", dymo->dither.out_width);\n\n\tpapplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n\t// Match roll number to loaded media...\n\tfor (i = 0; i < data.num_source; i ++)\n\t{\n\t  if (data.media_ready[i].size_width == options->media.size_width && data.media_ready[i].size_length == options->media.size_length)\n\t    break;\n\t}\n\n\tif (i >= data.num_source)\n\t{\n\t  // No match, so use what the client sent...\n\t  i = !strcmp(options->media.source, \"alternate-roll\");\n\t}\n\n\tpapplDevicePrintf(device, \"\\033q%d\", i + 1);\n\n\tif (darkness < 0)\n\t  darkness = 0;\n\telse if (darkness > 100)\n\t  darkness = 100;\n\n\tpapplDevicePrintf(device, \"\\033%c\", density[3 * darkness / 100]);\n\tbreak;\n\n    case LPRINT_DLANG_TAPE :\n        // Set line width...\n        papplDevicePrintf(device, \"\\033D%c\", 0);\n\n        // Feed for the leader...\n\tmemset(buffer, 0x16, dymo->normal_leader);\n\tpapplDeviceWrite(device, buffer, dymo->normal_leader);\n\n        // Set indentation...\n        papplDevicePrintf(device, \"\\033B%c\", 0);\n        break;\n  }\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-dymo.c",
    "start_line": 440,
    "signature": "lprint_dymo_rstartpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_dymo_t\t\t*dymo = (lprint_dymo_t *)papplJobGetData(job);\n\t\t\t\t\t// DYMO driver data\n  unsigned char\t\tbyte;\t\t// Byte to write\n\n\n  if (!lprintDitherLine(&dymo->dither, y, line))\n    return (true);\n\n  if (dymo->dither.output[0] || memcmp(dymo->dither.output, dymo->dither.output + 1, dymo->dither.out_width - 1))\n  {\n    // Not a blank line\n    switch (dymo->dlang)\n    {\n      case LPRINT_DLANG_LABEL :\n\t  // Feed for any prior blank lines...\n\t  if (dymo->feed)\n\t  {\n\t    while (dymo->feed > 255)\n\t    {\n\t      papplDevicePrintf(device, \"\\033f\\001%c\", 255);\n\t      dymo->feed -= 255;\n\t    }\n\n\t    papplDevicePrintf(device, \"\\033f\\001%c\", dymo->feed);\n\t    dymo->feed = 0;\n\t  }\n\n\t  // Then write the non-blank line...\n\t  byte = 0x16;\n\t  papplDeviceWrite(device, &byte, 1);\n\t  papplDeviceWrite(device, dymo->dither.output, dymo->dither.out_width);\n\t  break;\n\n      case LPRINT_DLANG_TAPE :\n\t  if (dymo->feed)\n\t  {\n\t    unsigned char buffer[256];\t// Write buffer\n\n            papplDevicePrintf(device, \"\\033D%c\", 0);\n\t    memset(buffer, 0x16, sizeof(buffer));\n\t    while (dymo->feed > 255)\n\t    {\n\t      papplDeviceWrite(device, buffer, sizeof(buffer));\n\t      dymo->feed -= 256;\n\t    }\n\n            if (dymo->feed > 0)\n            {\n\t      papplDeviceWrite(device, buffer, dymo->feed);\n\t      dymo->feed = 0;\n\t    }\n\t  }\n\t  papplDevicePrintf(device, \"\\033D%c\\026\", dymo->dither.out_width);\n\t  papplDeviceWrite(device, dymo->dither.output, dymo->dither.out_width);\n          break;\n    }\n  }\n  else\n  {\n    // Blank line, accumulate the feed...\n    dymo->feed ++;\n  }\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-dymo.c",
    "start_line": 529,
    "signature": "lprint_dymo_rwriteline( pappl_job_t         *job,\t\t// I - Job pappl_pr_options_t  *options,\t// I - Job options pappl_device_t      *device,\t// I - Output device unsigned            y,\t\t// I - Line number const unsigned char *line)\t\t// I - Line"
  },
  {
    "content": "{\n  (void)printer;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-dymo.c",
    "start_line": 608,
    "signature": "lprint_dymo_status( pappl_printer_t *printer)\t\t// I - Printer"
  },
  {
    "content": "{\n  data->printfile_cb  = lprint_epl2_printfile;\n  data->rendjob_cb    = lprint_epl2_rendjob;\n  data->rendpage_cb   = lprint_epl2_rendpage;\n  data->rstartjob_cb  = lprint_epl2_rstartjob;\n  data->rstartpage_cb = lprint_epl2_rstartpage;\n  data->rwriteline_cb = lprint_epl2_rwriteline;\n  data->status_cb     = lprint_epl2_status;\n  data->format        = LPRINT_EPL2_MIMETYPE;\n\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  if (strstr(driver_name, \"-cutter\"))\n    data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if (!strncmp(driver_name, \"epl2_2inch-\", 16))\n  {\n    // 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_epl2_2inch_media) / sizeof(lprint_epl2_2inch_media[0]));\n    memcpy(data->media, lprint_epl2_2inch_media, sizeof(lprint_epl2_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_epl2_4inch_media) / sizeof(lprint_epl2_4inch_media[0]));\n    memcpy(data->media, lprint_epl2_4inch_media, sizeof(lprint_epl2_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  data->bottom_top = data->left_right = 1;\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  data->num_type = 3;\n  data->type[0]  = \"continuous\";\n  data->type[1]  = \"labels\";\n  data->type[2]  = \"labels-continuous\";\n\n  data->mode_configured = PAPPL_LABEL_MODE_TEAR_OFF;\n  data->mode_supported = PAPPL_LABEL_MODE_APPLICATOR | PAPPL_LABEL_MODE_CUTTER | PAPPL_LABEL_MODE_CUTTER_DELAYED | PAPPL_LABEL_MODE_KIOSK | PAPPL_LABEL_MODE_PEEL_OFF | PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL | PAPPL_LABEL_MODE_REWIND | PAPPL_LABEL_MODE_RFID | PAPPL_LABEL_MODE_TEAR_OFF;\n\n  data->speed_default      = 0;\n  data->speed_supported[0] = 2540;\n  data->speed_supported[1] = 6 * 2540;\n\n  data->darkness_configured = 50;\n  data->darkness_supported  = 30;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-epl2.c",
    "start_line": 137,
    "signature": "lprintEPL2( pappl_system_t         *system,\t// I - System const char             *driver_name,// I - Driver name const char             *device_uri,\t// I - Device URI const char             *device_id,\t// I - 1284 device ID pappl_pr_driver_data_t *data,\t// I - Pointer to driver data ipp_t                  **attrs,\t// O - Pointer to driver attributes void                   *cbdata)\t// I - Callback data (not used)"
  },
  {
    "content": "{\n  int\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd  = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file '%s': %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-epl2.c",
    "start_line": 221,
    "signature": "lprint_epl2_printfile( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_dither_t *dither = (lprint_dither_t *)papplJobGetData(job);\n\t\t\t\t\t// Dither buffer\n\n\n  (void)options;\n  (void)device;\n\n  free(dither);\n  papplJobSetData(job, NULL);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-epl2.c",
    "start_line": 262,
    "signature": "lprint_epl2_rendjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_dither_t *dither = (lprint_dither_t *)papplJobGetData(job);\n\t\t\t\t\t// Dither buffer\n\n\n  (void)page;\n\n  lprint_epl2_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  papplDevicePuts(device, \"P1\\n\");\n\n  if (options->finishings & PAPPL_FINISHINGS_TRIM)\n    papplDevicePuts(device, \"C\\n\");\n\n  // Free memory and return...\n  lprintDitherFree(dither);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-epl2.c",
    "start_line": 286,
    "signature": "lprint_epl2_rendpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_dither_t *dither = (lprint_dither_t *)calloc(1, sizeof(lprint_dither_t));\n\t\t\t\t\t// Dither buffer\n\n\n  (void)options;\n  (void)device;\n\n  // Save dither buffer for job...\n  papplJobSetData(job, dither);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-epl2.c",
    "start_line": 317,
    "signature": "lprint_epl2_rstartjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  int\t\tips;\t\t\t// Inches per second\n  lprint_dither_t *dither = (lprint_dither_t *)papplJobGetData(job);\n\t\t\t\t\t// Dither buffer\n  int\t\tdarkness;\t\t// Composite darkness value\n  double\tout_gamma = 1.0;\t// Output gamma correction\n\n\n  (void)page;\n\n  // Initialize the dither buffer...\n  if (options->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n\n  if (!lprintDitherAlloc(dither, job, options, CUPS_CSPACE_W, out_gamma))\n    return (false);\n\n  // Start a new label...\n  papplDevicePuts(device, \"\\nN\\n\");\n\n  // print-darkness\n  if ((darkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"D%d\\n\", 15 * darkness / 100);\n\n  // print-speed\n  if ((ips = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"S%d\\n\", ips);\n\n  // Set label width...\n  papplDevicePrintf(device, \"q%u\\n\", dither->out_width * 8);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-epl2.c",
    "start_line": 341,
    "signature": "lprint_epl2_rstartpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_dither_t *dither = (lprint_dither_t *)papplJobGetData(job);\n\t\t\t\t\t// Dither buffer\n\n\n  if (!lprintDitherLine(dither, y, line))\n    return (true);\n\n  if (dither->output[0] || memcmp(dither->output, dither->output + 1, dither->out_width - 1))\n  {\n    // Not a blank line\n    papplDevicePrintf(device, \"GW0,%u,%u,1\\n\", y, dither->out_width);\n    papplDeviceWrite(device, dither->output, dither->out_width);\n    papplDevicePuts(device, \"\\n\");\n  }\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-epl2.c",
    "start_line": 390,
    "signature": "lprint_epl2_rwriteline( pappl_job_t         *job,\t\t// I - Job pappl_pr_options_t  *options,\t// I - Job options pappl_device_t      *device,\t// I - Output device unsigned            y,\t\t// I - Line number const unsigned char *line)\t\t// I - Line"
  },
  {
    "content": "{\n  (void)printer;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-epl2.c",
    "start_line": 421,
    "signature": "lprint_epl2_status( pappl_printer_t *printer)\t\t// I - Printer"
  },
  {
    "content": "{\n  LPRINT_SLP_CMD_NOP = 0x00,\n  LPRINT_SLP_CMD_STATUS,\n  LPRINT_SLP_CMD_VERSION,\n  LPRINT_SLP_CMD_BAUDRATE,\n  LPRINT_SLP_CMD_PRINT,\n  LPRINT_SLP_CMD_PRINTRLE,\n  LPRINT_SLP_CMD_MARGIN,\n  LPRINT_SLP_CMD_REPEAT,\n  LPRINT_SLP_CMD_TAB = 0x09,\n  LPRINT_SLP_CMD_LINEFEED,\n  LPRINT_SLP_CMD_VERTTAB,\n  LPRINT_SLP_CMD_FORMFEED,\n  LPRINT_SLP_CMD_SETSPEED,\n  LPRINT_SLP_CMD_DENSITY,\n  LPRINT_SLP_CMD_RESET,\n  LPRINT_SLP_CMD_MODEL = 0x12,\n  LPRINT_SLP_CMD_INDENT = 0x16,\n  LPRINT_SLP_CMD_FINEMODE,\n  LPRINT_SLP_CMD_SETSERIALNUM = 0x1B,\n  LPRINT_SLP_CMD_CHECK = 0xA5\n};",
    "source": "data/codebase\\lprint-sii.c",
    "start_line": 16,
    "signature": "enum lprint_slp_cmd_e"
  },
  {
    "content": "{\n  // Print callbacks...\n  data->printfile_cb  = lprint_sii_printfile;\n  data->rendjob_cb    = lprint_sii_rendjob;\n  data->rendpage_cb   = lprint_sii_rendpage;\n  data->rstartjob_cb  = lprint_sii_rstartjob;\n  data->rstartpage_cb = lprint_sii_rstartpage;\n  data->rwriteline_cb = lprint_sii_rwriteline;\n\n  // Vendor-specific format...\n  data->format = LPRINT_SLP_MIMETYPE;\n\n  // Set resolution...\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"_203dpi\") != NULL)\n    data->x_resolution[0] = data->y_resolution[0] = 203;\n  else\n    data->x_resolution[0] = data->y_resolution[0] = 300;\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  // Basically borderless...\n  data->left_right = 1;\n  data->bottom_top = 1;\n\n  // Supported media...\n  data->num_media = (int)(sizeof(lprint_sii_media) / sizeof(lprint_sii_media[0]));\n  memcpy(data->media, lprint_sii_media, sizeof(lprint_sii_media));\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  papplCopyString(data->media_ready[0].size_name, \"om_address-small_24x83mm\", sizeof(data->media_ready[0].size_name));\n  papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n\n  data->num_type = 1;\n  data->type[0]  = \"labels\";\n\n  // Darkness/density settings...\n  data->darkness_configured = 50;\n  data->darkness_supported  = 3;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-sii.c",
    "start_line": 103,
    "signature": "lprintSII( pappl_system_t         *system,\t// I - System const char             *driver_name,// I - Driver name const char             *device_uri,\t// I - Device URI const char             *device_id,\t// I - 1284 device ID pappl_pr_driver_data_t *data,\t// I - Pointer to driver data ipp_t                  **attrs,\t// O - Pointer to driver attributes void                   *cbdata)\t// I - Callback data (not used)"
  },
  {
    "content": "{\n  switch (atoi(driver_name + 7))\n  {\n    case 100 :\n    case 410 :\n\treturn (192);\n\tbreak;\n\n    case 200 :\n    case 240 :\n    case 420 :\n    case 430 :\n        return (384);\n        break;\n\n    default :\n        return (576);\n        break;\n  }\n}",
    "source": "data/codebase\\lprint-sii.c",
    "start_line": 163,
    "signature": "lprint_sii_get_max_width( const char *driver_name)\t\t// I - Driver name"
  },
  {
    "content": "{\n  const char\t*driver_name = papplPrinterGetDriverName(papplJobGetPrinter(job));\n\t\t\t\t\t// Driver name\n\n\n  (void)options;\n\n  // Initialize driver data and save it...\n  siidata->max_width = lprint_sii_get_max_width(driver_name);\n  switch (atoi(driver_name + 7))\n  {\n    case 100 :\n    case 410 :\n\t// Reset printer...\n\tpapplDevicePrintf(device, \"%c\", LPRINT_SLP_CMD_RESET);\n\tpapplDeviceFlush(device);\n\tsleep(3);\n\tbreak;\n\n    default :\n        // Nothing else to do...\n        break;\n  }\n\n  papplJobSetData(job, siidata);\n}",
    "source": "data/codebase\\lprint-sii.c",
    "start_line": 191,
    "signature": "static void lprint_sii_init( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device lprint_sii_t       *siidata)\t// O - Driver data"
  },
  {
    "content": "{\n  int\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n  lprint_sii_t\tsiidata;\t\t// Driver data\n\n\n  // Initialize driver data...\n  lprint_sii_init(job, options, device, &siidata);\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file \\\"%s\\\": %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-sii.c",
    "start_line": 230,
    "signature": "lprint_sii_printfile( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_sii_t\t\t*siidata = (lprint_sii_t *)papplJobGetData(job);\n\t\t\t\t\t// SII driver data\n\n  (void)options;\n\n  free(siidata);\n  papplJobSetData(job, NULL);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-sii.c",
    "start_line": 275,
    "signature": "lprint_sii_rendjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_sii_t\t*siidata = (lprint_sii_t *)papplJobGetData(job);\n\t\t\t\t\t// SII driver data\n\n\n  (void)page;\n\n  // Write last line\n  lprint_sii_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  // Eject\n  papplDevicePrintf(device, \"%c\", LPRINT_SLP_CMD_FORMFEED);\n  papplDeviceFlush(device);\n\n  // Free memory and return...\n  lprintDitherFree(&siidata->dither);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-sii.c",
    "start_line": 297,
    "signature": "lprint_sii_rendpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_sii_t\t\t*siidata = (lprint_sii_t *)calloc(1, sizeof(lprint_sii_t));\n\t\t\t\t\t// SII driver data\n\n\n  (void)options;\n\n  // Initialize driver data...\n  lprint_sii_init(job, options, device, siidata);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-sii.c",
    "start_line": 328,
    "signature": "lprint_sii_rstartjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_sii_t *siidata = (lprint_sii_t *)papplJobGetData(job);\n\t\t\t\t\t// SII driver data\n  const char\t*driver_name = papplPrinterGetDriverName(papplJobGetPrinter(job));\n\t\t\t\t\t// Driver name\n  int\t\tdarkness;\t\t// Combined density\n\n\n\n  (void)page;\n\n  // Initialize the dither buffer and blanks count...\n  if (!lprintDitherAlloc(&siidata->dither, job, options, CUPS_CSPACE_K, options->header.HWResolution[0] == 300 ? 1.2 : 1.0))\n    return (false);\n\n  papplDevicePrintf(device, \"%c%c\", LPRINT_SLP_CMD_MARGIN, (int)(12.7 * (lprint_sii_get_max_width(driver_name) - options->header.cupsWidth) / options->header.HWResolution[0]));\n\n  siidata->blanks = 0;\n\n  // Set darkness...\n  if ((darkness = options->darkness_configured + options->print_darkness) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"%c%c\", LPRINT_SLP_CMD_DENSITY, 3 * darkness / 100);\n\n  // Set quality...\n  switch (atoi(driver_name + 7))\n  {\n    case 100 :\n    case 200 :\n    case 240 :\n    case 410 :\n    case 420 :\n    case 430 :\n        papplDevicePrintf(device, \"%c%c\", LPRINT_SLP_CMD_FINEMODE, options->print_quality == IPP_QUALITY_HIGH ? 0x01 : 0x00);\n        break;\n\n    default :\n        papplDevicePrintf(device, \"%c%c\", LPRINT_SLP_CMD_SETSPEED, options->print_quality == IPP_QUALITY_HIGH ? 0x02 : 0x00);\n        break;\n  }\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-sii.c",
    "start_line": 351,
    "signature": "lprint_sii_rstartpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_sii_t\t\t*siidata = (lprint_sii_t *)papplJobGetData(job);\n\t\t\t\t\t// SII driver data\n\n\n  // Dither...\n  if (!lprintDitherLine(&siidata->dither, y, line))\n    return (true);\n\n  if (!siidata->dither.output[0] && !memcmp(siidata->dither.output, siidata->dither.output + 1, siidata->dither.out_width - 1))\n  {\n    // Skip blank lines...\n    siidata->blanks ++;\n    return (true);\n  }\n\n  // Feed past any blank lines...\n  while (siidata->blanks > 0)\n  {\n    if (siidata->blanks == 1)\n    {\n      papplDevicePuts(device, \"\\n\");\n      siidata->blanks = 0;\n    }\n    else if (siidata->blanks < 255)\n    {\n      papplDevicePrintf(device, \"%c%c\", LPRINT_SLP_CMD_VERTTAB, (char)siidata->blanks);\n      siidata->blanks = 0;\n    }\n    else\n    {\n      papplDevicePrintf(device, \"%c%c\", LPRINT_SLP_CMD_VERTTAB, (char)255);\n      siidata->blanks -= 255;\n    }\n  }\n\n  // Output bitmap data...\n  papplDevicePrintf(device, \"%c%c\", LPRINT_SLP_CMD_PRINT, (char)siidata->dither.out_width);\n  papplDeviceWrite(device, siidata->dither.output, siidata->dither.out_width);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-sii.c",
    "start_line": 409,
    "signature": "lprint_sii_rwriteline( pappl_job_t         *job,\t\t// I - Job pappl_pr_options_t  *options,\t// I - Job options pappl_device_t      *device,\t// I - Output device unsigned            y,\t\t// I - Line number const unsigned char *line)\t\t// I - Line"
  },
  {
    "content": "{\n  pappl_pr_driver_data_t data;\t\t// Printer driver data\n  pappl_pr_options_t\t*options = papplJobCreatePrintOptions(job, 1, false);\n\t\t\t\t\t// Print options\n  unsigned char\t*line = NULL,\t\t// Output line\n\t\t*lineptr;\t\t// Pointer into line\n  unsigned\twidth,\t\t\t// Width accounting for margins\n\t\theight,\t\t\t// Height accounting for margins\n\t\ty,\t\t\t// Current position in page\n\t\tytop, yend, ybottom,\t// Top/end-of-image/bottom lines in page\n\t\txc,\t\t\t// X count\n\t\tx1mm, y1mm,\t\t// Number of columns/rows per pixel (nominally 1mm)\n\t\txleft,\t\t\t// Start for line\n\t\tpw, ph;\t\t\t// Image width and height\n  const char\t**pixels,\t\t// Output image pixels\n\t\t*pixel;\t\t\t// Current output pixel\n  bool\t\tret = false;\t\t// Return value\n  static const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n  static const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n\n  (void)cbdata;\n\n  // Validate options and allocate a line buffer...\n  if (!options)\n    goto done;\n\n  if ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n  width  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n  height = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"Printable area for test page is %ux%u pixels.\", width, height);\n\n  if (width > height)\n  {\n    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n  else\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n  y1mm = 10 * options->header.HWResolution[1] / 254;\n  if ((y1mm * ph) > height)\n  {\n    if ((y1mm = height / ph) == 0)\n      y1mm = 1;\n  }\n\n  if ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n  if ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, x1mm=%u, y1mm=%u\", pw, ph, x1mm, y1mm);\n\n  if (((pw + 2) * x1mm) > options->header.cupsWidth || ((ph + 2) * y1mm) > options->header.cupsHeight)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Label too small to print test page.\");\n    goto done;\n  }\n\n  pw *= x1mm;\n  ph *= y1mm;\n\n  xleft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n  ytop    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n  yend    = ytop + ph;\n  ybottom = options->header.cupsHeight - y1mm;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, ytop=%u, yend=%u, ybottom=%u\", pw, ph, ytop, yend, ybottom);\n\n  // Start the page...\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  papplJobSetImpressions(job, 1);\n\n  if (!(data.rstartjob_cb)(job, options, device))\n    goto done;\n\n  if (!(data.rstartpage_cb)(job, options, device, 1))\n    goto done;\n\n  // Send lines for the test label:\n  //\n  // +---------------+\n  // |...............|\n  // |...         ...|\n  // |... T E S T ...|\n  // |...         ...|\n  // |...............|\n  // +---------------+\n\n  // Top border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (y = 0; y < y1mm; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on upper half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ytop; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders, gray shading, and image pixels in middle\n  for (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on lower half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ybottom; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Bottom border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (; y < options->header.cupsHeight; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Finish up...\n  if (!(data.rendpage_cb)(job, options, device, 1))\n    goto done;\n\n  if (!(data.rendjob_cb)(job, options, device))\n    goto done;\n\n  ret = true;\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  done:\n\n  free(line);\n  papplJobDeletePrintOptions(options);\n\n  return (ret);\n}",
    "source": "data/codebase\\lprint-testpage.c",
    "start_line": 17,
    "signature": "lprintTestFilterCB( pappl_job_t    *job,\t\t// I - Job pappl_device_t *device,\t\t// I - Output device void           *cbdata)\t\t// I - Callback data (not used)"
  },
  {
    "content": "{\n  int\tfd;\t\t\t\t// File descriptor\n  char\ttestpage[] = LPRINT_TESTPAGE_HEADER;\n\t\t\t\t\t// Test page file header\n\n\n  if ((fd = papplCreateTempFile(buffer, bufsize, \"testpage\", \"tst\")) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Unable to create temporary file for test page: %s\", strerror(errno));\n    return (NULL);\n  }\n\n  if (write(fd, testpage, sizeof(testpage)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Unable to write temporary file for test page: %s\", strerror(errno));\n    close(fd);\n    return (NULL);\n  }\n\n  close(fd);\n\n  return (buffer);\n}",
    "source": "data/codebase\\lprint-testpage.c",
    "start_line": 295,
    "signature": "lprintTestPageCB( pappl_printer_t *printer,\t\t// I - Printer char            *buffer,\t\t// I - Filename buffer size_t          bufsize)\t\t// I - Size of filename buffer"
  },
  {
    "content": "{\n  // Print callbacks...\n  data->printfile_cb  = lprint_tspl_printfile;\n  data->rendjob_cb    = lprint_tspl_rendjob;\n  data->rendpage_cb   = lprint_tspl_rendpage;\n  data->rstartjob_cb  = lprint_tspl_rstartjob;\n  data->rstartpage_cb = lprint_tspl_rstartpage;\n  data->rwriteline_cb = lprint_tspl_rwriteline;\n  data->status_cb     = lprint_tspl_status;\n\n  // Vendor-specific format...\n  data->format = LPRINT_TSPL_MIMETYPE;\n\n  // Set resolution...\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"_203dpi\") != NULL)\n    data->x_resolution[0] =  data->y_resolution[0] = 203;\n  else\n    data->x_resolution[0] =  data->y_resolution[0] = 300;\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  // Basically borderless...\n  data->left_right = 1;\n  data->bottom_top = 1;\n\n  // Supported media...\n  data->num_media = (int)(sizeof(lprint_tspl_media) / sizeof(lprint_tspl_media[0]));\n  memcpy(data->media, lprint_tspl_media, sizeof(lprint_tspl_media));\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n  papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  data->media_ready[0].tracking = PAPPL_MEDIA_TRACKING_GAP;\n\n  data->num_type = 2;\n  data->type[0]  = \"labels\";\n  data->type[1]  = \"continuous\";\n\n  data->tracking_supported = PAPPL_MEDIA_TRACKING_GAP | PAPPL_MEDIA_TRACKING_MARK | PAPPL_MEDIA_TRACKING_CONTINUOUS;\n\n  data->speed_default = 0;\n  data->speed_supported[0] = 2540;\n  data->speed_supported[1] = 12 * 2540;\n\n  // Darkness/density settings...\n  data->darkness_configured = 50;\n  data->darkness_supported  = 16;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-tspl.c",
    "start_line": 108,
    "signature": "lprintTSPL( pappl_system_t         *system,\t// I - System const char             *driver_name,// I - Driver name const char             *device_uri,\t// I - Device URI const char             *device_id,\t// I - 1284 device ID pappl_pr_driver_data_t *data,\t// I - Pointer to driver data ipp_t                  **attrs,\t// O - Pointer to driver attributes void                   *cbdata)\t// I - Callback data (not used)"
  },
  {
    "content": "{\n  int\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd  = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file '%s': %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-tspl.c",
    "start_line": 177,
    "signature": "lprint_tspl_printfile( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_tspl_t\t\t*tspl = (lprint_tspl_t *)papplJobGetData(job);\n\t\t\t\t\t// TSPL driver data\n\n  (void)options;\n  (void)device;\n\n  free(tspl);\n  papplJobSetData(job, NULL);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-tspl.c",
    "start_line": 218,
    "signature": "lprint_tspl_rendjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_tspl_t\t*tspl = (lprint_tspl_t *)papplJobGetData(job);\n\t\t\t\t\t// TSPL driver data\n\n\n  (void)page;\n\n  // Write last line\n  lprint_tspl_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  // Eject\n  if (options->header.NumCopies)\n    papplDevicePrintf(device, \"PRINT %u,1\\n\", options->header.NumCopies);\n  else\n    papplDevicePuts(device, \"PRINT 1,1\\n\");\n  papplDeviceFlush(device);\n\n  // Free memory and return...\n  lprintDitherFree(&tspl->dither);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-tspl.c",
    "start_line": 241,
    "signature": "lprint_tspl_rendpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_tspl_t\t\t*tspl = (lprint_tspl_t *)calloc(1, sizeof(lprint_tspl_t));\n\t\t\t\t\t// TSPL driver data\n\n\n  (void)options;\n  (void)device;\n\n  // Save driver data...\n  papplJobSetData(job, tspl);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-tspl.c",
    "start_line": 275,
    "signature": "lprint_tspl_rstartjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_tspl_t\t*tspl = (lprint_tspl_t *)papplJobGetData(job);\n\t\t\t\t\t// TSPL driver data\n  int\t\tdarkness,\t\t// Combined density\n\t\tspeed;\t\t\t// Print speed\n\n\n  (void)page;\n\n  // Initialize the dither buffer...\n  if (!lprintDitherAlloc(&tspl->dither, job, options, CUPS_CSPACE_W, options->header.HWResolution[0] == 300 ? 1.2 : 1.0))\n    return (false);\n\n  // Initialize the printer...\n  if ((darkness = options->darkness_configured + options->print_darkness) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"SIZE %d mm,%d mm\\n\", options->media.size_width / 100, options->media.size_length / 100);\n\n  switch (options->orientation_requested)\n  {\n    default :\n    case IPP_ORIENT_PORTRAIT :\n        papplDevicePuts(device, \"DIRECTION 0,0\\n\");\n        break;\n    case IPP_ORIENT_LANDSCAPE :\n        papplDevicePuts(device, \"DIRECTION 90,0\\n\");\n        break;\n    case IPP_ORIENT_REVERSE_PORTRAIT :\n        papplDevicePuts(device, \"DIRECTION 180,0\\n\");\n        break;\n    case IPP_ORIENT_REVERSE_LANDSCAPE :\n        papplDevicePuts(device, \"DIRECTION 270,0\\n\");\n        break;\n  }\n\n  switch (options->media.tracking)\n  {\n    default :\n        break;\n\n    case PAPPL_MEDIA_TRACKING_CONTINUOUS :\n        papplDevicePuts(device, \"GAP 0 mm,0 mm\\n\");\n        break;\n    case PAPPL_MEDIA_TRACKING_MARK :\n        papplDevicePuts(device, \"BLINE 3 mm,0 mm\\n\");\n        break;\n    case PAPPL_MEDIA_TRACKING_GAP :\n        papplDevicePuts(device, \"GAP 3 mm,0 mm\\n\");\n        break;\n  }\n\n  papplDevicePrintf(device, \"DENSITY %d\\n\", (darkness * 15 + 50) / 100);\n  if ((speed = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"SPEED %d\\n\", speed);\n\n  // Start the page image...\n  papplDevicePuts(device, \"CLS\\n\");\n  papplDevicePrintf(device, \"BITMAP 0,0,%u,%u,1,\", tspl->dither.out_width, options->header.cupsHeight);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-tspl.c",
    "start_line": 299,
    "signature": "lprint_tspl_rstartpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_tspl_t\t\t*tspl = (lprint_tspl_t *)papplJobGetData(job);\n\t\t\t\t\t// TSPL driver data\n\n\n  (void)options;\n\n  // Dither and write the line...\n  if (lprintDitherLine(&tspl->dither, y, line))\n    papplDeviceWrite(device, tspl->dither.output, tspl->dither.out_width);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-tspl.c",
    "start_line": 375,
    "signature": "lprint_tspl_rwriteline( pappl_job_t         *job,\t\t// I - Job pappl_pr_options_t  *options,\t// I - Job options pappl_device_t      *device,\t// I - Output device unsigned            y,\t\t// I - Line number const unsigned char *line)\t\t// I - Line"
  },
  {
    "content": "{\n  (void)printer;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-tspl.c",
    "start_line": 401,
    "signature": "lprint_tspl_status( pappl_printer_t *printer)\t\t// I - Printer"
  },
  {
    "content": "{\n  data->printfile_cb  = lprint_zpl_printfile;\n  data->rendjob_cb    = lprint_zpl_rendjob;\n  data->rendpage_cb   = lprint_zpl_rendpage;\n  data->rstartjob_cb  = lprint_zpl_rstartjob;\n  data->rstartpage_cb = lprint_zpl_rstartpage;\n  data->rwriteline_cb = lprint_zpl_rwriteline;\n  data->status_cb     = lprint_zpl_status;\n  data->format        = LPRINT_ZPL_MIMETYPE;\n\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else if (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  if (strstr(driver_name, \"-cutter\"))\n    data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if (!strncmp(driver_name, \"zpl_2inch-\", 16))\n  {\n    // 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  data->media_ready[0].tracking = PAPPL_MEDIA_TRACKING_GAP;\n\n  data->bottom_top = data->left_right = 1;\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  data->top_offset_supported[0] = -1500;\n  data->top_offset_supported[1] = 1500;\n  data->tracking_supported      = PAPPL_MEDIA_TRACKING_MARK | PAPPL_MEDIA_TRACKING_WEB | PAPPL_MEDIA_TRACKING_GAP | PAPPL_MEDIA_TRACKING_CONTINUOUS;\n\n  data->num_type = 3;\n  data->type[0]  = \"continuous\";\n  data->type[1]  = \"labels\";\n  data->type[2]  = \"labels-continuous\";\n\n  data->mode_configured = PAPPL_LABEL_MODE_TEAR_OFF;\n  data->mode_supported = PAPPL_LABEL_MODE_APPLICATOR | PAPPL_LABEL_MODE_CUTTER | PAPPL_LABEL_MODE_CUTTER_DELAYED | PAPPL_LABEL_MODE_KIOSK | PAPPL_LABEL_MODE_PEEL_OFF | PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL | PAPPL_LABEL_MODE_REWIND | PAPPL_LABEL_MODE_RFID | PAPPL_LABEL_MODE_TEAR_OFF;\n\n  data->tear_offset_configured   = 0;\n  data->tear_offset_supported[0] = -1500;\n  data->tear_offset_supported[1] = 1500;\n\n  data->speed_default      = 0;\n  data->speed_supported[0] = 2540;\n  data->speed_supported[1] = 12 * 2540;\n\n  data->darkness_configured = 50;\n  data->darkness_supported  = 30;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-zpl.c",
    "start_line": 193,
    "signature": "lprintZPL( pappl_system_t         *system,\t// I - System const char             *driver_name,// I - Driver name const char             *device_uri,\t// I - Device URI const char             *device_id,\t// I - 1284 device ID pappl_pr_driver_data_t *data,\t// I - Pointer to driver data ipp_t                  **attrs,\t// O - Pointer to driver attributes void                   *cbdata)\t// I - Callback data (not used)"
  },
  {
    "content": "{\n  pappl_device_t\t*device;\t// Device connection\n  char\t\t\tline[1025];\t// Line from device\n  ssize_t\t\tbytes;\t\t// Bytes read\n  char\t\t\tmodel[256],\t// Model name\n\t\t\t*modelptr;\t// Pointer into model name\n  int\t\t\tdpmm = 0;\t// Dots per millimeter\n\n\n  // Make sure name buffer is initialized...\n  *name = '\\0';\n\n  // Connect and send Host Information command...\n  if ((device = papplDeviceOpen(device_uri, \"query\", papplLogDevice, system)) == NULL)\n    return;\n\n  if (papplDevicePuts(device, \"~HI\\n\") < 0)\n    goto done;\n\n  // Read and parse response:\n  //\n  // <stx>MODEL,VERSION,DPMM,MEMORY,OPTIONS<etx><cr><lf>\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) <= 0)\n    goto done;\n\n  line[bytes] = '\\0';\n\n  papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"HI response for '%s' was '%s'.\", device_uri, line);\n\n  if (line[0] == 0x02 && sscanf(line + 1, \"%255[^,],%*[^,],%d\", model, &dpmm) > 1 && (dpmm == 8 || dpmm == 12 || dpmm == 24))\n  {\n    // Got model and dots-per-millimeter values, create a driver name from it...\n    // Note: We currently assume a 4\" print head for auto-detection...\n    const char\t*type = \"tt\";\t\t// Type of printing (direct/transfer)\n    int\t\tdpi;\t\t\t// Print resolution\n\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"model='%s', dpmm=%d\", model, dpmm);\n\n    if ((modelptr = strchr(model, '-')) != NULL && modelptr > model)\n    {\n      if (modelptr[-1] == 'd')\n        type = \"dt\";\n    }\n\n    if (dpmm == 8)\n      dpi = 203;\t\t\t// 203.2\n    else if (dpmm == 12)\n      dpi = 300;\t\t\t// Technically should be 304.8...\n    else\n      dpi = 600;\t\t\t// Technically should be 609.6...\n\n    snprintf(name, namesize, \"zpl_4inch-%ddpi-%s\", dpi, type);\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"auto driver-name='%s'\", name);\n  }\n\n  done:\n\n  papplDeviceClose(device);\n  return;\n}",
    "source": "data/codebase\\lprint-zpl.c",
    "start_line": 291,
    "signature": "void lprintZPLQueryDriver( pappl_system_t *system,\t\t// I - System const char     *device_uri,\t\t// I - Device URI char           *name,\t\t// I - Name buffer size_t         namesize)\t\t// I - Size of name buffer"
  },
  {
    "content": "{\n  unsigned char\tbuffer[8192],\t\t// Output buffer\n\t\t*bufptr = buffer;\t// Pointer into buffer\n\n\n  if (count > 1)\n  {\n    // Print as many z's as possible - they are the largest denomination\n    // representing 400 characters (zC stands for 400 adjacent C's)\n    while (count >= 400)\n    {\n      count -= 400;\n      *bufptr++ = 'z';\n\n      if (bufptr >= (buffer + sizeof(buffer)))\n      {\n        if (papplDeviceWrite(device, buffer, sizeof(buffer)) < 0)\n          return (0);\n\n\tbufptr = buffer;\n      }\n    }\n\n    // Then print 'g' through 'y' as multiples of 20 characters...\n    if (count >= 20)\n    {\n      *bufptr++ = 'f' + count / 20;\n      count %= 20;\n    }\n\n    // Finally, print 'G' through 'Y' as 1 through 19 characters...\n    if (count > 0)\n      *bufptr++ = 'F' + count;\n  }\n\n  // Then the character to be repeated...\n  *bufptr++ = ch;\n\n  return (papplDeviceWrite(device, buffer, bufptr - buffer) > 0);\n}",
    "source": "data/codebase\\lprint-zpl.c",
    "start_line": 365,
    "signature": "lprint_zpl_compress( pappl_device_t *device,\t\t// I - Output device unsigned char  ch,\t\t\t// I - Repeat character unsigned       count)\t\t// I - Repeat count"
  },
  {
    "content": "{\n  int\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd  = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file '%s': %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Copy print data...\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-zpl.c",
    "start_line": 417,
    "signature": "lprint_zpl_printfile( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)options;\n\n  free(zpl);\n  papplJobSetData(job, NULL);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-zpl.c",
    "start_line": 465,
    "signature": "lprint_zpl_rendjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)page;\n\n  lprint_zpl_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  papplDevicePrintf(device, \"^XA\\n^POI\\n^PW%u\\n^LH0,0\\n^LT%d\\n\", options->header.cupsWidth, options->media.top_offset * options->printer_resolution[1] / 2540);\n\n  if (options->media.type[0] && strcmp(options->media.type, \"labels\"))\n  {\n    // Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if (options->media.tracking)\n  {\n    if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if (strstr(papplPrinterGetDriverName(papplJobGetPrinter(job)), \"-tt\"))\n    papplDevicePuts(device, \"^MTT\\n\");\t// Thermal transfer\n  else\n    papplDevicePuts(device, \"^MTD\\n\");\t// Direct thermal\n\n  papplDevicePrintf(device, \"^PQ1, 0, 0, N\\n\");\n  papplDevicePuts(device, \"^FO0,0^XGR:LPRINT.GRF,1,1^FS\\n^XZ\\n\");\n  papplDevicePuts(device, \"^XA\\n^IDR:LPRINT.GRF^FS\\n^XZ\\n\");\n\n  if (options->finishings & PAPPL_FINISHINGS_TRIM)\n    papplDevicePuts(device, \"^CN1\\n\");\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Free memory and return...\n  lprintDitherFree(&zpl->dither);\n\n  free(zpl->comp_buffer);\n  free(zpl->last_buffer);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-zpl.c",
    "start_line": 488,
    "signature": "lprint_zpl_rendpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  pappl_pr_driver_data_t data;\t\t// Driver data\n  int\t\t\tdarkness;\t// Composite darkness value\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)calloc(1, sizeof(lprint_zpl_t));\n\t\t\t\t\t// ZPL driver data\n\n\n  // Initialize driver data...\n  papplJobSetData(job, zpl);\n\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  // label-mode-configured\n  switch (data.mode_configured)\n  {\n    case PAPPL_LABEL_MODE_APPLICATOR :\n        papplDevicePuts(device, \"^MMA,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER :\n        papplDevicePuts(device, \"^MMC,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER_DELAYED :\n        papplDevicePuts(device, \"^MMD,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_KIOSK :\n        papplDevicePuts(device, \"^MMK,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF :\n        papplDevicePuts(device, \"^MMP,N\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL :\n        papplDevicePuts(device, \"^MMP,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_REWIND :\n        papplDevicePuts(device, \"^MMR,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_RFID :\n        papplDevicePuts(device, \"^MMF,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_TEAR_OFF :\n    default :\n        papplDevicePuts(device, \"^MMT,Y\\n\");\n        break;\n  }\n\n  // label-tear-offset-configured\n  if (data.tear_offset_configured < 0)\n    papplDevicePrintf(device, \"~TA%04d\\n\", data.tear_offset_configured);\n  else if (data.tear_offset_configured > 0)\n    papplDevicePrintf(device, \"~TA%03d\\n\", data.tear_offset_configured);\n\n  // print-darkness / printer-darkness-configured\n  if ((darkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"~SD%02u\\n\", 30 * darkness / 100);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-zpl.c",
    "start_line": 550,
    "signature": "lprint_zpl_rstartjob( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device)\t\t// I - Output device"
  },
  {
    "content": "{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  int\t\tips;\t\t\t// Inches per second\n  double\tout_gamma = 1.0;\t// Output gamma correction\n\n\n  (void)page;\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Setup dither buffer...\n  if (options->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n  else if (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if (!lprintDitherAlloc(&zpl->dither, job, options, CUPS_CSPACE_K, out_gamma))\n    return (false);\n\n  // print-speed\n  if ((ips = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"^PR%d,%d,%d\\n\", ips, ips, ips);\n\n  // Download bitmap...\n  papplDevicePrintf(device, \"~DGR:LPRINT.GRF,%u,%u,\\n\", zpl->dither.in_height * zpl->dither.out_width, zpl->dither.out_width);\n\n  // Allocate memory for writing the bitmap...\n  zpl->comp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zpl->last_buffer     = malloc(zpl->dither.out_width);\n  zpl->last_buffer_set = 0;\n\n  if (!zpl->comp_buffer || !zpl->last_buffer)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate compression buffers.\");\n    return (false);\n  }\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-zpl.c",
    "start_line": 622,
    "signature": "lprint_zpl_rstartpage( pappl_job_t        *job,\t\t// I - Job pappl_pr_options_t *options,\t// I - Job options pappl_device_t     *device,\t\t// I - Output device unsigned           page)\t\t// I - Page number"
  },
  {
    "content": "{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  unsigned\t\ti;\t\t// Looping var\n  const unsigned char\t*ptr;\t\t// Pointer into buffer\n  unsigned char\t\t*compptr;\t// Pointer into compression buffer\n#if ZPL_COMPRESSION\n  unsigned char\t\trepeat_char;\t// Repeated character\n  unsigned\t\trepeat_count;\t// Number of repeated characters\n#endif // ZPL_COMPRESSION\n  static const unsigned char *hex = (const unsigned char *)\"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n\n  if (!lprintDitherLine(&zpl->dither, y, line))\n    return (true);\n\n  // Determine whether this row is the same as the previous line.\n  // If so, output a ':' and return...\n  if (zpl->last_buffer_set && !memcmp(zpl->dither.output, zpl->last_buffer, zpl->dither.out_width))\n  {\n    papplDeviceWrite(device, \":\", 1);\n    return (true);\n  }\n\n  // Convert the line to hex digits...\n  for (ptr = zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > 0; i --, ptr ++)\n  {\n    *compptr++ = hex[*ptr >> 4];\n    *compptr++ = hex[*ptr & 15];\n  }\n\n#if ZPL_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZPL_COMPRESSION\n\n  // Save this line for the next round...\n  memcpy(zpl->last_buffer, zpl->dither.output, zpl->dither.out_width);\n  zpl->last_buffer_set = 1;\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-zpl.c",
    "start_line": 675,
    "signature": "lprint_zpl_rwriteline( pappl_job_t         *job,\t\t// I - Job pappl_pr_options_t  *options,\t// I - Job options pappl_device_t      *device,\t// I - Output device unsigned            y,\t\t// I - Line number const unsigned char *line)\t\t// I - Line"
  },
  {
    "content": "{\n  pappl_device_t\t*device;\t// Connection to printer\n  char\t\t\tline[1025];\t// Line from printer\n  ssize_t\t\tbytes;\t\t// Bytes read\n  int\t\t\tlength = 0;\t// Label length\n  bool\t\t\tret = false;\t// Return value\n\n\n  if ((device = papplPrinterOpenDevice(printer)) == NULL)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to open device for status.\");\n    return (false);\n  }\n\n  // Get the printer status...\n  if (!lprint_zpl_update_reasons(printer, NULL, device))\n    goto done;\n\n  // Query host status...\n  if (papplDevicePuts(device, \"~HS\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HS status command.\");\n    goto done;\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HS status response.\");\n    goto done;\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HS returned '%s'.\", line);\n\n  if (sscanf(line + 1, \"%*d,%*d,%*d,%d\", &length) == 1 && length > 11)\n  {\n    // Auto-detect label length for ready media...\n    pappl_pr_driver_data_t\tdata;\t// Driver data\n\n    papplPrinterGetDriverData(printer, &data);\n\n    // Round the length to the nearest dot and snap to the nearest 1/4\"...\n    length = (2540 * length + data.y_resolution[0] / 2) / data.y_resolution[0];\n\n    if ((length % 635) <= 100)\n      length += length % 635;\n    else if ((length % 635) >= 535)\n      length += 635 - (length % 635);\n\n    // Lookup size\n    lprintMediaMatch(printer, 0, 0, length);\n  }\n\n  ret = true;\n\n  done:\n\n  papplPrinterCloseDevice(printer);\n\n  return (ret);\n}",
    "source": "data/codebase\\lprint-zpl.c",
    "start_line": 765,
    "signature": "lprint_zpl_status( pappl_printer_t *printer)\t\t// I - Printer"
  },
  {
    "content": "{\n  char\t\t\tline[1025],\t// Line from printer\n\t\t\t*lineptr;\t// Pointer into line\n  ssize_t\t\tbytes;\t\t// Bytes read\n  unsigned\t\terrors = 0,\t// Detected errors\n\t\t\twarnings = 0;\t// Detected warnings\n  pappl_preason_t\treasons;\t// \"printer-state-reasons\" values\n\n\n  // Get the printer status...\n  if (papplDevicePuts(device, \"~HQES\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HQES status command.\");\n    return (false);\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HQES status response.\");\n    return (false);\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HQES returned '%s'.\", line);\n\n  if ((lineptr = strstr(line, \"ERRORS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 7, \"%*d%*x%x\", &errors) != 1)\n      errors = 0;\n  }\n\n  if ((lineptr = strstr(line, \"WARNINGS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 9, \"%*d%*x%x\", &warnings) != 1)\n      warnings = 0;\n  }\n\n  reasons = PAPPL_PREASON_NONE;\n\n  if (errors & ZPL_ERROR_MEDIA_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_EMPTY;\n\n  if (errors & ZPL_ERROR_PAPER_JAM)\n    reasons |= PAPPL_PREASON_MEDIA_JAM;\n\n  if (errors & ZPL_ERROR_PAUSED)\n    reasons |= PAPPL_PREASON_OFFLINE;\n\n  if (errors & ZPL_ERROR_RIBBON_OUT)\n    reasons |= PAPPL_PREASON_MARKER_SUPPLY_EMPTY;\n\n  if (errors & ~(ZPL_ERROR_MEDIA_OUT | ZPL_ERROR_PAPER_JAM | ZPL_ERROR_PAUSED))\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_ERROR_HEAD_OPEN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Print head open.\");\n    if (errors & ZPL_ERROR_CUTTER_FAULT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Cutter fault.\");\n    if (errors & ZPL_ERROR_CLEAR_PP_FAILED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Clear paper path failed.\");\n    if (errors & ZPL_ERROR_PAPER_FEED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Paper feed error.\");\n    if (errors & ZPL_ERROR_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Presenter error.\");\n    if (errors & ZPL_ERROR_MARK_NOT_FOUND)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark not found.\");\n    if (errors & ZPL_ERROR_MARK_CALIBRATE)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark calibration error.\");\n    if (errors & ZPL_ERROR_RETRACT_TIMEOUT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Retraction timeout.\");\n  }\n\n  if (warnings & ZPL_WARNING_PAPER_ALMOST_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_LOW;\n\n  if (warnings & ~ZPL_WARNING_PAPER_ALMOST_OUT)\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_WARNING_REPLACE_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Replace print head.\");\n\n    if (errors & ZPL_WARNING_CLEAN_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Clean print head.\");\n\n    if (errors & ZPL_WARNING_CALIBRATE_MEDIA)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Calibrate media.\");\n\n    if (errors & ZPL_WARNING_PAPER_BEFORE_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper before head.\");\n\n    if (errors & ZPL_WARNING_BLACK_MARK)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Black mark.\");\n\n    if (errors & ZPL_WARNING_PAPER_AFTER_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper after head.\");\n\n    if (errors & ZPL_WARNING_LOOP_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Loop ready.\");\n\n    if (errors & ZPL_WARNING_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Presenter.\");\n\n    if (errors & ZPL_WARNING_RETRACT_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Retract ready.\");\n\n    if (errors & ZPL_WARNING_IN_RETRACT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"In retract.\");\n\n    if (errors & ZPL_WARNING_AT_BIN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"At bin.\");\n  }\n\n  if (job && (reasons & PAPPL_PREASON_MEDIA_EMPTY))\n    reasons |= PAPPL_PREASON_MEDIA_NEEDED;\n\n  papplPrinterSetReasons(printer, reasons, ~reasons);\n\n  return (true);\n}",
    "source": "data/codebase\\lprint-zpl.c",
    "start_line": 836,
    "signature": "lprint_zpl_update_reasons( pappl_printer_t *printer,\t\t// I - Printer pappl_job_t     *job,\t\t// I - Current job or `NULL` if none pappl_device_t  *device)\t\t// I - Connection to device"
  },
  {
    "content": "{\n  char\t*device_info;\t\t\t// Device description\n  char\t*device_uri;\t\t\t// Device URI\n  char\t*device_id;\t\t\t// Device ID\n} lprint_device_t;",
    "source": "data/codebase\\lprint.c",
    "start_line": 25,
    "signature": "typedef struct lprint_device_s"
  },
  {
    "content": "{\n  int\t\ti,\t\t\t// Looping var\n\t\tscore,\t\t\t// Current driver match score\n\t    \tbest_score = 0,\t\t// Best score\n\t\tnum_did;\t\t// Number of device ID key/value pairs\n  cups_option_t\t*did;\t\t\t// Device ID key/value pairs\n  const char\t*make,\t\t\t// Manufacturer name\n\t\t*best_name = NULL;\t// Best driver\n  char\t\tname[1024] = \"\";\t// Driver name to match\n\n\n  (void)device_info;\n\n  // First parse the device ID and get any potential driver name to match...\n  num_did = papplDeviceParseID(device_id, &did);\n\n  if ((make = cupsGetOption(\"MANUFACTURER\", num_did, did)) == NULL)\n    if ((make = cupsGetOption(\"MANU\", num_did, did)) == NULL)\n      make = cupsGetOption(\"MFG\", num_did, did);\n\n  if (make && !strncasecmp(make, \"Zebra\", 5))\n    lprintZPLQueryDriver((pappl_system_t *)cbdata, device_uri, name, sizeof(name));\n\n  // Then loop through the driver list to find the best match...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(name, lprint_drivers[i].name))\n    {\n      // Matching driver name always the best match...\n      best_name = lprint_drivers[i].name;\n      break;\n    }\n\n    if (lprint_drivers[i].device_id)\n    {\n      // See if we have a matching device ID...\n      score = match_id(num_did, did, lprint_drivers[i].device_id);\n      if (score > best_score)\n      {\n        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n    }\n  }\n\n  // Clean up and return...\n  cupsFreeOptions(num_did, did);\n\n  return (best_name);\n}",
    "source": "data/codebase\\lprint.c",
    "start_line": 78,
    "signature": "return (papplMainloop(argc, argv, LPRINT_VERSION, \"Copyright &copy; 2019-2025 by Michael R Sweet. All Rights Reserved.\", (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])), lprint_drivers, autoadd_cb, driver_cb, /*subcmd_name*/NULL, /*subcmd_cb*/NULL, system_cb, /*usage_cb*/NULL, /*data*/NULL)); }   // // 'autoadd_cb()' - Determine the proper driver for a given printer. //  static const char *\t\t\t// O - Driver name or `NULL` for none autoadd_cb(const char *device_info,\t// I - Device information/name (not used) const char *device_uri,\t// I - Device URI const char *device_id,\t// I - IEEE-1284 device ID void       *cbdata)\t\t// I - Callback data (System)"
  },
  {
    "content": "{\n  char\t\t\tresource[1024];\t// Resource path\n  pappl_pr_driver_data_t data;\t\t// Driver data\n\n\n  (void)cbdata;\n\n  LPRINT_DEBUG(\"create_cb(printer=%p(%s), cbdata=%p)\\n\", printer, printer ? papplPrinterGetName(printer) : \"null\", cbdata);\n\n  // Add custom label media page to replace the standard ready media page...\n  papplSystemRemoveResource(papplPrinterGetSystem(printer), papplPrinterGetPath(printer, \"media\", resource, sizeof(resource)));\n  papplSystemAddResourceCallback(papplPrinterGetSystem(printer), resource, \"text/html\", (pappl_resource_cb_t)lprintMediaUI, printer);\n  LPRINT_DEBUG(\"create_cb: Added new media page for '%s'.\\n\", resource);\n\n  // Load custom media sizes and report them...\n  papplPrinterGetDriverData(printer, &data);\n  lprintMediaLoad(printer, &data);\n  lprintMediaUpdate(printer, &data);\n  papplPrinterSetDriverData(printer, &data, NULL);\n\n  LPRINT_DEBUG(\"create_cb: data.extension=%p\\n\", data.extension);\n}",
    "source": "data/codebase\\lprint.c",
    "start_line": 182,
    "signature": "static void create_cb(pappl_printer_t *printer,\t// I - Printer void            *cbdata)\t// I - Callback data (not used)"
  },
  {
    "content": "{\n  bool\tret = false;\t\t\t// Return value\n  int\ti;\t\t\t\t// Looping var\n\n\n  // Copy make/model info...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(driver_name, lprint_drivers[i].name))\n    {\n      papplCopyString(data->make_and_model, lprint_drivers[i].description, sizeof(data->make_and_model));\n      break;\n    }\n  }\n\n  // AirPrint version...\n  data->num_features = 1;\n  data->features[0]  = \"airprint-2.1\";\n\n  // Pages per minute (interpret as \"labels per minute\")\n  data->ppm = 60;\n\n  // \"printer-kind\" values...\n  data->kind = PAPPL_KIND_LABEL;\n\n  // Color values...\n  data->color_supported = PAPPL_COLOR_MODE_AUTO | PAPPL_COLOR_MODE_MONOCHROME | PAPPL_COLOR_MODE_BI_LEVEL;\n  data->color_default   = PAPPL_COLOR_MODE_MONOCHROME;\n  data->raster_types    = PAPPL_PWG_RASTER_TYPE_BLACK_1 | PAPPL_PWG_RASTER_TYPE_BLACK_8 | PAPPL_PWG_RASTER_TYPE_SGRAY_8;\n\n  // \"print-quality-default\" value...\n  data->quality_default = IPP_QUALITY_NORMAL;\n\n  // \"sides\" values...\n  data->sides_supported = PAPPL_SIDES_ONE_SIDED;\n  data->sides_default   = PAPPL_SIDES_ONE_SIDED;\n\n  // \"orientation-requested-default\" value...\n  data->orient_default = IPP_ORIENT_NONE;\n\n  // Media capabilities...\n  data->input_face_up  = true;\n  data->output_face_up = true;\n\n  // Standard icons...\n  data->icons[0].data    = lprint_small_png;\n  data->icons[0].datalen = sizeof(lprint_small_png);\n  data->icons[1].data    = lprint_png;\n  data->icons[1].datalen = sizeof(lprint_png);\n  data->icons[2].data    = lprint_large_png;\n  data->icons[2].datalen = sizeof(lprint_large_png);\n\n  // Test page callback...\n  data->testpage_cb = lprintTestPageCB;\n\n  // Use the corresponding sub-driver callback to set things up...\n#ifdef LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"brother_\", 8))\n    ret = lprintBrother(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"cpcl_\", 5))\n    ret = lprintCPCL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else\n#endif // LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"dymo_\", 5))\n    ret = lprintDYMO(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"epl2_\", 5))\n    ret = lprintEPL2(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"sii_\", 4))\n    ret = lprintSII(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"tspl_\", 5))\n    ret = lprintTSPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"zpl_\", 4))\n    ret = lprintZPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n\n  // Update the ready media...\n  for (i = 0; i < data->num_source; i ++)\n  {\n    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n  // By default use media from the main source...\n  data->media_default = data->media_ready[0];\n\n  // Return...\n  return (ret);\n}",
    "source": "data/codebase\\lprint.c",
    "start_line": 214,
    "signature": "driver_cb( pappl_system_t         *system,\t// I - System const char             *driver_name,// I - Driver name const char             *device_uri,\t// I - Device URI const char             *device_id,\t// I - 1284 device ID pappl_pr_driver_data_t *data,\t// I - Pointer to driver data ipp_t                  **attrs,\t// O - Pointer to driver attributes void                   *cbdata)\t// I - Callback data (not used)"
  },
  {
    "content": "{\n  free(dev->device_info);\n  free(dev->device_uri);\n  free(dev->device_id);\n  free(dev);\n}",
    "source": "data/codebase\\lprint.c",
    "start_line": 324,
    "signature": "static void free_cb(lprint_device_t *dev)\t\t// I - Device entry"
  },
  {
    "content": "      {\n        // No match\n        score = 0;\n        break;\n      }",
    "source": "data/codebase\\lprint.c",
    "start_line": 384,
    "signature": "else"
  },
  {
    "content": "    {\n      // No match\n      score = 0;\n      break;\n    }",
    "source": "data/codebase\\lprint.c",
    "start_line": 391,
    "signature": "else"
  },
  {
    "content": "{\n  lprint_device_t\tdev;\t\t// New device\n\n\n  dev.device_info = (char *)device_info;\n  dev.device_uri  = (char *)device_uri;\n  dev.device_id   = (char *)device_id;\n\n  cupsArrayAdd(devices, &dev);\n\n  return (false);\n}",
    "source": "data/codebase\\lprint.c",
    "start_line": 424,
    "signature": "else return (NULL); }   // // 'printer_cb()' - Try auto-adding printers. //  static bool\t\t\t\t// O - `false` to continue printer_cb(const char   *device_info,\t// I - Device information const char   *device_uri,\t// I - Device URI const char   *device_id,\t// I - IEEE-1284 device ID cups_array_t *devices)\t// I - Device array"
  },
  {
    "content": "{\n  pappl_system_t\t*system;\t// System object\n  const char\t\t*val,\t\t// Current option value\n\t\t\t*hostname,\t// Hostname, if any\n\t\t\t*listenhost,\t// Listen hostname, if any\n\t\t\t*logfile,\t// Log file, if any\n\t\t\t*spooldir,\t// Spool directory, if any\n\t\t\t*system_name;\t// System name, if any\n  char\t\t\toldfile[1024];\t// Old configuration filename\n  pappl_loglevel_t\tloglevel;\t// Log level\n  int\t\t\tport = 0;\t// Port number, if any\n  pappl_soptions_t\tsoptions = PAPPL_SOPTIONS_MULTI_QUEUE | PAPPL_SOPTIONS_WEB_INTERFACE | PAPPL_SOPTIONS_WEB_LOG | PAPPL_SOPTIONS_WEB_SECURITY | PAPPL_SOPTIONS_WEB_TLS;\n\t\t\t\t\t// System options\n  static pappl_version_t versions[1] =\t// Software versions\n  {\n    { \"LPrint\", \"\", LPRINT_VERSION, { LPRINT_MAJOR_VERSION, LPRINT_MINOR_VERSION, LPRINT_PATCH_VERSION, 0 } }\n  };\n\n\n  (void)data;\n\n  // Parse standard log and server options...\n  if ((val = cupsGetOption(\"log-level\", num_options, options)) != NULL)\n  {\n    if (!strcmp(val, \"fatal\"))\n      loglevel = PAPPL_LOGLEVEL_FATAL;\n    else if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n  }\n  else\n    loglevel = PAPPL_LOGLEVEL_UNSPEC;\n\n  if ((val = cupsGetOption(\"server-options\", num_options, options)) != NULL)\n  {\n    const char\t*valptr;\t\t// Pointer into value\n\n    for (valptr = val; valptr && *valptr;)\n    {\n      if (!strcmp(valptr, \"none\") || !strncmp(valptr, \"none,\", 5))\n        soptions = PAPPL_SOPTIONS_NONE;\n      else if (!strcmp(valptr, \"dnssd-host\") || !strncmp(valptr, \"dnssd-host,\", 11))\n        soptions |= PAPPL_SOPTIONS_DNSSD_HOST;\n      else if (!strcmp(valptr, \"no-multi-queue\") || !strncmp(valptr, \"no-multi-queue,\", 15))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_MULTI_QUEUE;\n      else if (!strcmp(valptr, \"raw-socket\") || !strncmp(valptr, \"raw-socket,\", 11))\n        soptions |= PAPPL_SOPTIONS_RAW_SOCKET;\n      else if (!strcmp(valptr, \"usb-printer\") || !strncmp(valptr, \"usb-printer,\", 12))\n        soptions |= PAPPL_SOPTIONS_USB_PRINTER;\n      else if (!strcmp(valptr, \"no-web-interface\") || !strncmp(valptr, \"no-web-interface,\", 17))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_WEB_INTERFACE;\n      else if (!strcmp(valptr, \"web-log\") || !strncmp(valptr, \"web-log,\", 8))\n        soptions |= PAPPL_SOPTIONS_WEB_LOG;\n      else if (!strcmp(valptr, \"web-network\") || !strncmp(valptr, \"web-network,\", 12))\n        soptions |= PAPPL_SOPTIONS_WEB_NETWORK;\n      else if (!strcmp(valptr, \"web-remote\") || !strncmp(valptr, \"web-remote,\", 11))\n        soptions |= PAPPL_SOPTIONS_WEB_REMOTE;\n      else if (!strcmp(valptr, \"web-security\") || !strncmp(valptr, \"web-security,\", 13))\n        soptions |= PAPPL_SOPTIONS_WEB_SECURITY;\n      else if (!strcmp(valptr, \"no-tls\") || !strncmp(valptr, \"no-tls,\", 7))\n        soptions = (pappl_soptions_t)((soptions | PAPPL_SOPTIONS_NO_TLS) & ~PAPPL_SOPTIONS_WEB_TLS);\n\n      if ((valptr = strchr(valptr, ',')) != NULL)\n        valptr ++;\n    }\n  }\n\n  hostname    = cupsGetOption(\"server-hostname\", num_options, options);\n  listenhost  = cupsGetOption(\"listen-hostname\", num_options, options);\n  logfile     = cupsGetOption(\"log-file\", num_options, options);\n  spooldir    = cupsGetOption(\"spool-directory\", num_options, options);\n  system_name = cupsGetOption(\"system-name\", num_options, options);\n\n  if ((val = cupsGetOption(\"server-port\", num_options, options)) != NULL)\n  {\n    if (!isdigit(*val & 255))\n    {\n      fprintf(stderr, \"lprint: Bad server-port value '%s'.\\n\", val);\n      return (NULL);\n    }\n    else\n      port = atoi(val);\n  }\n\n  // Spool directory and state file...\n  if ((val = getenv(\"SNAP_DATA\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else if ((val = getenv(\"XDG_DATA_HOME\")) != NULL)\n  {\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n  }\n#ifdef _WIN32\n  else if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/AppData/Local/lprint.ini\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/AppData/Local/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#else\n  else if ((val = getenv(\"HOME\")) != NULL)\n  {\n#  ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif // __APPLE__\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/etc/lprint.conf\", sizeof(oldfile));\n#  ifdef __APPLE__\n    papplCopyString(lprint_statefile, \"/private/var/lib/lprint.state\", sizeof(lprint_statefile));\n#  else\n    papplCopyString(lprint_statefile, \"/var/lib/lprint.state\", sizeof(lprint_statefile));\n#  endif // __APPLE__\n  }\n#endif // _WIN32\n\n  if (!access(oldfile, 0) && access(lprint_statefile, 0))\n  {\n    // Move old state file to new name...\n    rename(oldfile, lprint_statefile);\n  }\n\n  if (spooldir && access(spooldir, 0))\n  {\n    if (mkdir(spooldir, 0777))\n    {\n      perror(spooldir);\n      return (NULL);\n    }\n  }\n\n  // Create the system object...\n  if ((system = papplSystemCreate(soptions, system_name ? system_name : \"LPrint\", port, \"_print,_universal\", spooldir, logfile ? logfile : \"-\", loglevel, cupsGetOption(\"auth-service\", num_options, options), /* tls_only */false)) == NULL)\n    return (NULL);\n\n  if (!cupsGetOption(\"private-server\", num_options, options))\n  {\n    // Listen for TCP/IP connections...\n    papplSystemAddListeners(system, listenhost);\n  }\n\n  papplSystemSetHostName(system, hostname);\n\n  if ((val = cupsGetOption(\"admin-group\", num_options, options)) != NULL)\n    papplSystemSetAdminGroup(system, val);\n\n  papplSystemSetMIMECallback(system, mime_cb, NULL);\n  papplSystemAddMIMEFilter(system, LPRINT_TESTPAGE_MIMETYPE, \"image/pwg-raster\", lprintTestFilterCB, NULL);\n\n  papplSystemSetPrinterDrivers(system, (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])), lprint_drivers, autoadd_cb, create_cb, driver_cb, system);\n\n  papplSystemAddResourceData(system, \"/favicon.png\", \"image/png\", lprint_small_png, sizeof(lprint_small_png));\n  papplSystemAddResourceData(system, \"/navicon.png\", \"image/png\", lprint_png, sizeof(lprint_png));\n  papplSystemAddResourceString(system, \"/style.css\", \"text/css\", lprint_css);\n  papplSystemAddStringsData(system, \"/de.strings\", \"de\", lprint_de_strings);\n  papplSystemAddStringsData(system, \"/en.strings\", \"en\", lprint_en_strings);\n  papplSystemAddStringsData(system, \"/es.strings\", \"es\", lprint_es_strings);\n  papplSystemAddStringsData(system, \"/fr.strings\", \"fr\", lprint_fr_strings);\n  papplSystemAddStringsData(system, \"/it.strings\", \"it\", lprint_it_strings);\n\n  papplSystemSetFooterHTML(system, \"Copyright &copy; 2019-2024 by Michael R Sweet. All rights reserved.\");\n  papplSystemSetSaveCallback(system, (pappl_save_cb_t)papplSystemSaveState, (void *)lprint_statefile);\n  papplSystemSetVersions(system, (int)(sizeof(versions) / sizeof(versions[0])), versions);\n\n  if (!papplSystemLoadState(system, lprint_statefile))\n  {\n    // No old state, use defaults and auto-add printers...\n    cups_array_t\t*devices;\t// Device array\n    lprint_device_t\t*dev;\t\t// Current device\n\n    papplSystemSetDNSSDName(system, system_name ? system_name : \"LPrint\");\n\n    papplLog(system, PAPPL_LOGLEVEL_INFO, \"Auto-adding printers...\");\n    devices = cupsArrayNew(NULL, NULL, NULL, 0, (cups_acopy_cb_t)copy_cb, (cups_afree_cb_t)free_cb);\n    papplDeviceList(PAPPL_DEVTYPE_USB, (pappl_device_cb_t)printer_cb, devices, papplLogDevice, system);\n\n    for (dev = (lprint_device_t *)cupsArrayGetFirst(devices); dev; dev = (lprint_device_t *)cupsArrayGetNext(devices))\n    {\n      const char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t\t\t\t\t// Driver name, if any\n\n      printf(\"%s (%s;%s) -> %s\\n\", dev->device_info, dev->device_uri, dev->device_id, driver_name);\n\n      if (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n    }\n\n    cupsArrayDelete(devices);\n  }\n\n  return (system);\n}",
    "source": "data/codebase\\lprint.c",
    "start_line": 457,
    "signature": "system_cb( int           num_options,\t\t// I - Number options cups_option_t *options,\t\t// I - Options void          *data)\t\t// I - Callback data (unused)"
  },
  {
    "content": "{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}",
    "source": "data/codebase\\test.h",
    "start_line": 98,
    "signature": "static inline void testBegin(const char *title, ...)\t// I - printf-style title string"
  },
  {
    "content": "{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}",
    "source": "data/codebase\\test.h",
    "start_line": 121,
    "signature": "static inline void testEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise"
  },
  {
    "content": "{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}",
    "source": "data/codebase\\test.h",
    "start_line": 140,
    "signature": "static inline void testEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise const char *message, ...)// I - printf-style message"
  },
  {
    "content": "{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}",
    "source": "data/codebase\\test.h",
    "start_line": 166,
    "signature": "static inline void testProgress(void)"
  },
  {
    "content": "{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}",
    "source": "data/codebase\\test.h",
    "start_line": 179,
    "signature": "static inline void testError(const char *error, ...)\t// I - printf-style error string"
  },
  {
    "content": "{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}",
    "source": "data/codebase\\test.h",
    "start_line": 200,
    "signature": "static inline void testMessage(const char *error, ...)\t// I - printf-style error string"
  },
  {
    "content": "{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}",
    "source": "data/codebase\\test.h",
    "start_line": 231,
    "signature": "static inline void testHexDump(const unsigned char *buffer,// I - Buffer size_t              bytes)\t// I - Number of bytes"
  },
  {
    "content": "  {\n    fputs(\"Usage: ./dithertest [--plain] INPUT.pwg >OUTPUT.pwg\\n\", stderr);\n    return (1);\n  }",
    "source": "data/codebase\\testdither.c",
    "start_line": 75,
    "signature": "else"
  },
  {
    "content": "    {\n      out_header.cupsColorOrder   = CUPS_ORDER_CHUNKED;\n      out_header.cupsColorSpace   = CUPS_CSPACE_K;\n      out_header.cupsBitsPerColor = 1;\n      out_header.cupsBitsPerPixel = 1;\n      out_header.cupsBytesPerLine = (out_header.cupsWidth + 7) / 8;\n      out_header.cupsNumColors    = 1;\n    }",
    "source": "data/codebase\\testdither.c",
    "start_line": 117,
    "signature": "if (plain)"
  },
  {
    "content": "    {\n      out_header.cupsColorOrder   = CUPS_ORDER_CHUNKED;\n      out_header.cupsColorSpace   = CUPS_CSPACE_SRGB;\n      out_header.cupsBitsPerColor = 8;\n      out_header.cupsBitsPerPixel = 24;\n      out_header.cupsBytesPerLine = out_header.cupsWidth * 3;\n      out_header.cupsNumColors    = 3;\n    }",
    "source": "data/codebase\\testdither.c",
    "start_line": 126,
    "signature": "else"
  },
  {
    "content": "    {\n      if (plain)\n        cupsRasterWritePixels(out_ras, dither.output, out_header.cupsBytesPerLine);\n      else\n\twrite_line(&dither, y, out_ras, &out_header, out_line);\n    }",
    "source": "data/codebase\\testdither.c",
    "start_line": 166,
    "signature": "if (plain) cupsRasterWritePixels(out_ras, dither.output, out_header.cupsBytesPerLine); else write_line(&dither, y, out_ras, &out_header, out_line); } }  if (lprintDitherLine(&dither, y, NULL))"
  },
  {
    "content": "{\n  unsigned\t\tcount;\t\t// Number of pixels left\n  unsigned char\t\t*out_ptr,\t// Pointer into output line\n\t\t\t*dptr,\t\t// Pointer into dither output\n\t\t\tdbit;\t\t// Bit in dither output\n  unsigned char\t\t*in_ptr;\t// Pointer into input line\n\n\n  // Provide a color-coded version of the dithered output, with blue showing\n  // repeated areas...\n  for (count = dither->in_width, out_ptr = out_line, dptr = dither->output, dbit = 128, in_ptr = dither->input[(y - 1) & 3]; count > 0; count --, in_ptr ++)\n  {\n    // Set the current output pixel color...\n    if (*dptr & dbit)\n    {\n      // Black or dark blue\n      if (*in_ptr < 255)\n      {\n\t// Dark yellow for gray that came out black\n\t*out_ptr++ = 79 - *in_ptr / 8;\n\t*out_ptr++ = 79 - *in_ptr / 8;\n\t*out_ptr++ = 31;\n      }\n      else\n      {\n        // Black\n\t*out_ptr++ = 0;\n\t*out_ptr++ = 0;\n        *out_ptr++ = 0;\n      }\n    }\n    else if (*in_ptr)\n    {\n      // Yellow for gray that came out white\n      *out_ptr++ = 255 - *in_ptr / 4;\n      *out_ptr++ = 255 - *in_ptr / 4;\n      *out_ptr++ = 127;\n    }\n    else\n    {\n      // White\n      *out_ptr++ = 255;\n      *out_ptr++ = 255;\n      *out_ptr++ = 255;\n    }\n\n    // Advance to the next bit in the dithered output...\n    if (dbit == 1)\n    {\n      dbit = 128;\n      dptr ++;\n    }\n    else\n    {\n      dbit /= 2;\n    }\n  }\n\n  // Write the output line and return...\n  cupsRasterWritePixels(out_ras, out_line, out_header->cupsBytesPerLine);\n}",
    "source": "data/codebase\\testdither.c",
    "start_line": 201,
    "signature": "static void write_line( lprint_dither_t    *dither,\t\t// Dither buffer unsigned           y,\t\t// Current line cups_raster_t      *out_ras,\t// Output raster stream cups_page_header_t *out_header,\t// Output page header unsigned char      *out_line)\t// Output line buffer"
  },
  {
    "content": "{\n  size_t\tinlen;\t\t\t// Length of input data\n  const char\t*input;\t\t\t// Input data\n  size_t\toutlen;\t\t\t// Length of output data\n  const char\t*output;\t\t// Output data\n} testdata_t;",
    "source": "data/codebase\\testpackbits.c",
    "start_line": 18,
    "signature": "typedef struct testdata_s"
  },
  {
    "content": "  {\n    testBegin(\"lprintPackBitsCompress(\\\"%s\\\")\", cases[i].input);\n    if ((dstlen = lprintPackBitsCompress(dst, (unsigned char *)cases[i].input, cases[i].inlen)) == cases[i].outlen)\n    {\n      if (!memcmp(dst, cases[i].output, cases[i].outlen))\n        testEnd(true);\n      else\n\ttestEndMessage(true, \"alternate bytes OK\");\n    }\n    else\n    {\n      testEndMessage(false, \"got %u bytes, expected %u bytes\", (unsigned)dstlen, (unsigned)cases[i].outlen);\n      testError(\"\\nSource Buffer:\");\n      testHexDump((unsigned char *)cases[i].input, cases[i].inlen);\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      testError(\"\\nExpected Buffer:\");\n      testHexDump((unsigned char *)cases[i].output, cases[i].outlen);\n    }\n  }",
    "source": "data/codebase\\testpackbits.c",
    "start_line": 103,
    "signature": "else testEndMessage(false, \"%s\", strerror(errno));  // Test specific values for (i = 0; i < (int)(sizeof(cases) / sizeof(cases[0])); i ++)"
  },
  {
    "content": "    {\n      // Add constant bytes\n      memset(src + offset, get_rand(), len);\n    }",
    "source": "data/codebase\\testpackbits.c",
    "start_line": 150,
    "signature": "else"
  },
  {
    "content": "{\n#if _WIN32\n  // rand_s uses real entropy...\n  unsigned v;\t\t\t\t// Random number\n\n\n  rand_s(&v);\n\n  return (v);\n\n#elif defined(__APPLE__)\n  // macOS/iOS arc4random() uses real entropy automatically...\n  return (arc4random());\n\n#else\n  // Use a Mersenne twister random number generator seeded from /dev/urandom...\n  unsigned\ti,\t\t\t// Looping var\n\t\ttemp;\t\t\t// Temporary value\n  static bool\tfirst_time = true;\t// First time we ran?\n  static unsigned mt_state[624],\t// Mersenne twister state\n\t\tmt_index;\t\t// Mersenne twister index\n\n\n  if (first_time)\n  {\n    int\t\tfd;\t\t\t// \"/dev/urandom\" file\n    struct timeval curtime;\t\t// Current time\n\n    // Seed the random number state...\n    if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n\n    if (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n\n    mt_index = 0;\n\n    for (i = 1; i < 624; i ++)\n      mt_state[i] = (unsigned)((1812433253 * (mt_state[i - 1] ^ (mt_state[i - 1] >> 30))) + i);\n\n    first_time = false;\n  }\n\n  if (mt_index == 0)\n  {\n    // Generate a sequence of random numbers...\n    unsigned i1 = 1, i397 = 397;\t// Looping vars\n\n    for (i = 0; i < 624; i ++)\n    {\n      temp        = (mt_state[i] & 0x80000000) + (mt_state[i1] & 0x7fffffff);\n      mt_state[i] = mt_state[i397] ^ (temp >> 1);\n\n      if (temp & 1)\n\tmt_state[i] ^= 2567483615u;\n\n      i1 ++;\n      i397 ++;\n\n      if (i1 == 624)\n\ti1 = 0;\n\n      if (i397 == 624)\n\ti397 = 0;\n    }\n  }\n\n  // Pull 32-bits of random data...\n  temp = mt_state[mt_index ++];\n  temp ^= temp >> 11;\n  temp ^= (temp << 7) & 2636928640u;\n  temp ^= (temp << 15) & 4022730752u;\n  temp ^= temp >> 18;\n\n  if (mt_index == 624)\n    mt_index = 0;\n\n  return (temp);\n#endif // _WIN32\n}",
    "source": "data/codebase\\testpackbits.c",
    "start_line": 197,
    "signature": "get_rand(void)"
  },
  {
    "content": "{\n  const unsigned char\t*srcptr,\t// Pointer into input buffer\n\t\t\t*srcend;\t// End of input buffer\n  unsigned char\t\t*dstptr,\t// Pointer into output buffer\n\t\t\t*dstend;\t// End of output buffer\n  unsigned\t\tcount;\t\t// Literal/repeat count\n\n\n  // Loop through the input buffer and decompress...\n  dstptr = dst;\n  dstend = dst + dstsize;\n  srcptr = src;\n  srcend = src + srclen;\n\n  while (srcptr < srcend)\n  {\n    if (*srcptr < 0x80)\n    {\n      // N literal bytes\n      count = *srcptr + 1;\n      srcptr ++;\n      if ((srcptr + count) > srcend)\n      {\n        testError(\"Literal count %u but only %ld input bytes remaining.\", count, srcend - srcptr);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Literal count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memcpy(dstptr, srcptr, count);\n      dstptr += count;\n      srcptr += count;\n    }\n    else if (*srcptr == 0x80)\n    {\n      testError(\"Undefined pack value 0x80 seen.\");\n    }\n    else\n    {\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n  }\n\n  return ((size_t)(dstptr - dst));\n}",
    "source": "data/codebase\\testpackbits.c",
    "start_line": 297,
    "signature": "uncompress_packbits( unsigned char       *dst,\t\t// I - Output buffer size_t              dstsize,\t// I - Size of output buffer const unsigned char *src,\t\t// I - Input buffer size_t              srclen)\t\t// I - Length of input buffer"
  }
]